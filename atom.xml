<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WordZzzz</title>
  
  <subtitle>My Awesome Site</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wordzzzz.github.io/"/>
  <updated>2018-01-28T05:51:11.704Z</updated>
  <id>https://wordzzzz.github.io/</id>
  
  <author>
    <name>Word Zzzz</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>鱼眼摄像头标定与畸变校正（双OPENCV版本）</title>
    <link href="https://wordzzzz.github.io/2018/01/28/OPENCV/"/>
    <id>https://wordzzzz.github.io/2018/01/28/OPENCV/</id>
    <published>2018-01-27T16:00:00.000Z</published>
    <updated>2018-01-28T05:51:11.704Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/fisheye_calibration" target="_blank" rel="noopener">https://github.com/WordZzzz/fisheye_calibration</a></strong></li><li><strong>软件版本：VS2013+OPENCV2.4.13 OR VS2013+OPENCV3.4.0</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><p>[toc]</p><h2 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a>我的代码</h2><p>&emsp;&emsp;最近在整理自己以前做过的一些东西，这是基于opencv的鱼眼摄像头畸变校正程序的<a href="https://github.com/WordZzzz/fisheye_calibration" target="_blank" rel="noopener">github地址</a>。</p><p>其中：</p><ul><li>normal_calibrate：基于OPENCV2与OPENCV3通用的函数实现，可实现USB摄像头实时畸变校正；</li><li>fishey_calibrate：基于OPENCV3独有的fishyey结构体实现，可实现USB摄像头实时畸变校正；</li><li>fishey_calibrate_img：基于OPENCV3独有的fishyey结构体实现，可实现单张图片畸变校正；</li></ul><p>&emsp;&emsp;opencv1.0 2.0版只有一种摄像机标定模型，就是普通的小孔成像模型，在cv：：空间下。而从opencv3.0开始，新增了一种鱼眼相机标定模型，在fisheye::空间下。两种模型的主要区别在于像与物的投影关系不同，具体的文献资料依然是数不胜数，这里就不赘述。根据opencv官方文档的建议，在畸变程度较大的广角镜头（比如：鱼眼镜头）上进行摄像机标定和畸变校正，最好是用fisheye模型，该模型在图像边缘畸变程度很大的地方比普通相机模型的效果要好。</p><p>&emsp;&emsp;当然，还是要贴上官方文档的：</p><ul><li><a href="https://docs.opencv.org/2.4/doc/tutorials/calib3d/camera_calibration/camera_calibration.html" target="_blank" rel="noopener">Camera calibration With OpenCV2</a>；</li><li><a href="https://docs.opencv.org/trunk/db/d58/group__calib3d__fisheye.html" target="_blank" rel="noopener">Camera calibration With OpenCV3</a>；</li></ul><hr><p>华丽的分割线</p><hr><h2 id="可供参考资料"><a href="#可供参考资料" class="headerlink" title="可供参考资料"></a>可供参考资料</h2><p>&emsp;&emsp;以下是在写这篇博客的时候偶然发现的对opencv两个版本标定过程的讲解，这里直接copy过来并稍微做了一下排版，因为自己忙于为找工作做准备，实在是没时间自己整理了。<a href="http://www.cnblogs.com/riddick/p/7811877.html" target="_blank" rel="noopener">原文链接</a>。</p><p>&emsp;&emsp;图像算法中会经常用到摄像机的畸变校正，有必要总结分析OpenCV中畸变校正方法，其中包括普通针孔相机模型和鱼眼相机模型fisheye两种畸变校正方法。</p><p>&emsp;&emsp;普通相机模型畸变校正函数针对OpenCV中的cv::initUndistortRectifyMap()，鱼眼相机模型畸变校正函数对应OpenCV中的cv::fisheye::initUndistortRectifyMap()。两种方法算出映射Mapx和Mapy后，统一用cv::Remap()函数进行插值得到校正后的图像。</p><h3 id="FishEye模型的畸变校正。"><a href="#FishEye模型的畸变校正。" class="headerlink" title="FishEye模型的畸变校正。"></a>FishEye模型的畸变校正。</h3><p>&emsp;&emsp;方便起见，直接贴出OpenCV源码，我在里面加了注释说明。建议参考<a href="https://docs.opencv.org/3.0-beta/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#fisheye-initundistortrectifymap" target="_blank" rel="noopener">OpenCV官方文档</a>看畸变模型原理会更清楚。</p><p>&emsp;&emsp;简要流程就是：</p><ul><li><p>1.求内参矩阵的逆，由于摄像机坐标系的三维点到二维图像平面，需要乘以旋转矩阵R和内参矩阵K。那么反向投影回去则是二维图像坐标乘以  K*R的逆矩阵。</p></li><li><p>2.将目标图像中的每一个像素点坐标(j,i)，乘以1中求出的逆矩阵iR，转换到摄像机坐标系（_x,_y,_w）,并归一化得到z=1平面下的三维坐标(x,y,1)。</p></li><li><p>3.求出平面模型下像素点对应鱼眼半球模型下的极坐标(r, theta)。</p></li><li><p>4.利用鱼眼畸变模型求出拥有畸变时像素点对应的theta_d。</p></li></ul><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20180128134953810?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><br><p></p><ul><li><p>5.利用求出的theta_d值将三维坐标点重投影到二维图像平面得到(u,v)，(u,v)即为目标图像对应的畸变图像中像素点坐标。</p></li><li><p>6.使用cv::Remap（）函数，根据mapx,mapy取出对应坐标位置的像素值赋值给目标图像，一般采用双线性插值法，得到畸变校正后的目标图像。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2\opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> cv::fisheye::initUndistortRectifyMap( InputArray K, InputArray D, InputArray R, InputArray P,</span><br><span class="line">    <span class="keyword">const</span> cv::Size&amp; size, <span class="keyword">int</span> m1type, OutputArray map1, OutputArray map2 )</span><br><span class="line">&#123;</span><br><span class="line">    CV_Assert( m1type == CV_16SC2 || m1type == CV_32F || m1type &lt;=<span class="number">0</span> );</span><br><span class="line">    map1.create( size, m1type &lt;= <span class="number">0</span> ? CV_16SC2 : m1type );</span><br><span class="line">    map2.create( size, map1.type() == CV_16SC2 ? CV_16UC1 : CV_32F );</span><br><span class="line"></span><br><span class="line">    CV_Assert((K.depth() == CV_32F || K.depth() == CV_64F) &amp;&amp; (D.depth() == CV_32F || D.depth() == CV_64F));</span><br><span class="line">    CV_Assert((P.empty() || P.depth() == CV_32F || P.depth() == CV_64F) &amp;&amp; (R.empty() || R.depth() == CV_32F || R.depth() == CV_64F));</span><br><span class="line">    CV_Assert(K.size() == Size(<span class="number">3</span>, <span class="number">3</span>) &amp;&amp; (D.empty() || D.total() == <span class="number">4</span>));</span><br><span class="line">    CV_Assert(R.empty() || R.size() == Size(<span class="number">3</span>, <span class="number">3</span>) || R.total() * R.channels() == <span class="number">3</span>);</span><br><span class="line">    CV_Assert(P.empty() || P.size() == Size(<span class="number">3</span>, <span class="number">3</span>) || P.size() == Size(<span class="number">4</span>, <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从内参矩阵K中取出归一化焦距fx,fy; cx,cy</span></span><br><span class="line">    cv::Vec2d f, c;</span><br><span class="line">    <span class="keyword">if</span> (K.depth() == CV_32F)</span><br><span class="line">    &#123;</span><br><span class="line">        Matx33f camMat = K.getMat();</span><br><span class="line">        f = Vec2f(camMat(<span class="number">0</span>, <span class="number">0</span>), camMat(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">        c = Vec2f(camMat(<span class="number">0</span>, <span class="number">2</span>), camMat(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Matx33d camMat = K.getMat();</span><br><span class="line">        f = Vec2d(camMat(<span class="number">0</span>, <span class="number">0</span>), camMat(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">        c = Vec2d(camMat(<span class="number">0</span>, <span class="number">2</span>), camMat(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从畸变系数矩阵D中取出畸变系数k1,k2,k3,k4</span></span><br><span class="line">    Vec4d k = Vec4d::all(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!D.empty())</span><br><span class="line">        k = D.depth() == CV_32F ? (Vec4d)*D.getMat().ptr&lt;Vec4f&gt;(): *D.getMat().ptr&lt;Vec4d&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//旋转矩阵RR转换数据类型为CV_64F，如果不需要旋转，则RR为单位阵</span></span><br><span class="line">    cv::Matx33d RR  = cv::Matx33d::eye();</span><br><span class="line">    <span class="keyword">if</span> (!R.empty() &amp;&amp; R.total() * R.channels() == <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cv::Vec3d rvec;</span><br><span class="line">        R.getMat().convertTo(rvec, CV_64F);</span><br><span class="line">        RR = Affine3d(rvec).rotation();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!R.empty() &amp;&amp; R.size() == Size(<span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line">        R.getMat().convertTo(RR, CV_64F);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//新的内参矩阵PP转换数据类型为CV_64F</span></span><br><span class="line">    cv::Matx33d PP = cv::Matx33d::eye();</span><br><span class="line">    <span class="keyword">if</span> (!P.empty())</span><br><span class="line">        P.getMat().colRange(<span class="number">0</span>, <span class="number">3</span>).convertTo(PP, CV_64F);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关键一步：新的内参矩阵*旋转矩阵，然后利用SVD分解求出逆矩阵iR，后面用到</span></span><br><span class="line">    cv::Matx33d iR = (PP * RR).inv(cv::DECOMP_SVD);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反向映射，遍历目标图像所有像素位置，找到畸变图像中对应位置坐标(u,v)，并分别保存坐标(u,v)到mapx和mapy中</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size.height; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">float</span>* m1f = map1.getMat().ptr&lt;<span class="keyword">float</span>&gt;(i);</span><br><span class="line">        <span class="keyword">float</span>* m2f = map2.getMat().ptr&lt;<span class="keyword">float</span>&gt;(i);</span><br><span class="line">        <span class="keyword">short</span>*  m1 = (<span class="keyword">short</span>*)m1f;</span><br><span class="line">        ushort* m2 = (ushort*)m2f;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//二维图像平面坐标系-&gt;摄像机坐标系</span></span><br><span class="line">        <span class="keyword">double</span> _x = i*iR(<span class="number">0</span>, <span class="number">1</span>) + iR(<span class="number">0</span>, <span class="number">2</span>),</span><br><span class="line">               _y = i*iR(<span class="number">1</span>, <span class="number">1</span>) + iR(<span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">               _w = i*iR(<span class="number">2</span>, <span class="number">1</span>) + iR(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size.width; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//归一化摄像机坐标系，相当于假定在Z=1平面上</span></span><br><span class="line">            <span class="keyword">double</span> x = _x/_w, y = _y/_w;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//求鱼眼半球体截面半径r</span></span><br><span class="line">            <span class="keyword">double</span> r = <span class="built_in">sqrt</span>(x*x + y*y);</span><br><span class="line">            <span class="comment">//求鱼眼半球面上一点与光心的连线和光轴的夹角Theta</span></span><br><span class="line">            <span class="keyword">double</span> theta = <span class="built_in">atan</span>(r);</span><br><span class="line">            <span class="comment">//畸变模型求出theta_d，相当于有畸变的角度值</span></span><br><span class="line">            <span class="keyword">double</span> theta2 = theta*theta, theta4 = theta2*theta2, theta6 = theta4*theta2, theta8 = theta4*theta4;</span><br><span class="line">            <span class="keyword">double</span> theta_d = theta * (<span class="number">1</span> + k[<span class="number">0</span>]*theta2 + k[<span class="number">1</span>]*theta4 + k[<span class="number">2</span>]*theta6 + k[<span class="number">3</span>]*theta8);</span><br><span class="line">            <span class="comment">//利用有畸变的Theta值，将摄像机坐标系下的归一化三维坐标，重投影到二维图像平面，得到(j,i)对应畸变图像中的(u,v)</span></span><br><span class="line">            <span class="keyword">double</span> scale = (r == <span class="number">0</span>) ? <span class="number">1.0</span> : theta_d / r;</span><br><span class="line">            <span class="keyword">double</span> u = f[<span class="number">0</span>]*x*scale + c[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">double</span> v = f[<span class="number">1</span>]*y*scale + c[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//保存(u,v)坐标到mapx,mapy</span></span><br><span class="line">            <span class="keyword">if</span>( m1type == CV_16SC2 )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> iu = cv::saturate_cast&lt;<span class="keyword">int</span>&gt;(u*cv::INTER_TAB_SIZE);</span><br><span class="line">                <span class="keyword">int</span> iv = cv::saturate_cast&lt;<span class="keyword">int</span>&gt;(v*cv::INTER_TAB_SIZE);</span><br><span class="line">                m1[j*<span class="number">2</span>+<span class="number">0</span>] = (<span class="keyword">short</span>)(iu &gt;&gt; cv::INTER_BITS);</span><br><span class="line">                m1[j*<span class="number">2</span>+<span class="number">1</span>] = (<span class="keyword">short</span>)(iv &gt;&gt; cv::INTER_BITS);</span><br><span class="line">                m2[j] = (ushort)((iv &amp; (cv::INTER_TAB_SIZE<span class="number">-1</span>))*cv::INTER_TAB_SIZE + (iu &amp; (cv::INTER_TAB_SIZE<span class="number">-1</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>( m1type == CV_32FC1 )</span><br><span class="line">            &#123;</span><br><span class="line">                m1f[j] = (<span class="keyword">float</span>)u;</span><br><span class="line">                m2f[j] = (<span class="keyword">float</span>)v;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//这三条语句是上面 ”//二维图像平面坐标系-&gt;摄像机坐标系“的一部分，是矩阵iR的第一列，这样写能够简化计算</span></span><br><span class="line">            _x += iR(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            _y += iR(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            _w += iR(<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="普通相机模型的畸变校正"><a href="#普通相机模型的畸变校正" class="headerlink" title="普通相机模型的畸变校正"></a>普通相机模型的畸变校正</h3><p>&emsp;&emsp;同样建议参考<a href="https://docs.opencv.org/3.0-beta/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html" target="_blank" rel="noopener">OpenCV官方文档</a>阅读代码。</p><p>&emsp;&emsp;主要流程和上面Fisheye模型差不多，只有第4部分的畸变模型不一样，普通相机的畸变模型如下：</p><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20180128135032366?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><br><p></p> <p>&emsp;&emsp;同样把源代码贴上，并加上注解：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2\opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> cv::initUndistortRectifyMap( InputArray _cameraMatrix, InputArray _distCoeffs,</span><br><span class="line">                              InputArray _matR, InputArray _newCameraMatrix,</span><br><span class="line">                              Size size, <span class="keyword">int</span> m1type, OutputArray _map1, OutputArray _map2 )</span><br><span class="line">&#123;</span><br><span class="line">    Mat cameraMatrix = _cameraMatrix.getMat(), distCoeffs = _distCoeffs.getMat();</span><br><span class="line">    Mat matR = _matR.getMat(), newCameraMatrix = _newCameraMatrix.getMat();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( m1type &lt;= <span class="number">0</span> )</span><br><span class="line">        m1type = CV_16SC2;</span><br><span class="line">    CV_Assert( m1type == CV_16SC2 || m1type == CV_32FC1 || m1type == CV_32FC2 );</span><br><span class="line">    _map1.create( size, m1type );</span><br><span class="line">    Mat map1 = _map1.getMat(), map2;</span><br><span class="line">    <span class="keyword">if</span>( m1type != CV_32FC2 )</span><br><span class="line">    &#123;</span><br><span class="line">        _map2.create( size, m1type == CV_16SC2 ? CV_16UC1 : CV_32FC1 );</span><br><span class="line">        map2 = _map2.getMat();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        _map2.release();</span><br><span class="line"></span><br><span class="line">    Mat_&lt;<span class="keyword">double</span>&gt; R = Mat_&lt;<span class="keyword">double</span>&gt;::eye(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">    Mat_&lt;<span class="keyword">double</span>&gt; A = Mat_&lt;<span class="keyword">double</span>&gt;(cameraMatrix), Ar;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( !newCameraMatrix.empty() )</span><br><span class="line">        Ar = Mat_&lt;<span class="keyword">double</span>&gt;(newCameraMatrix);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        Ar = getDefaultNewCameraMatrix( A, size, <span class="literal">true</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( !matR.empty() )</span><br><span class="line">        R = Mat_&lt;<span class="keyword">double</span>&gt;(matR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( !distCoeffs.empty() )</span><br><span class="line">        distCoeffs = Mat_&lt;<span class="keyword">double</span>&gt;(distCoeffs);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        distCoeffs.create(<span class="number">14</span>, <span class="number">1</span>, CV_64F);</span><br><span class="line">        distCoeffs = <span class="number">0.</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CV_Assert( A.size() == Size(<span class="number">3</span>,<span class="number">3</span>) &amp;&amp; A.size() == R.size() );</span><br><span class="line">    CV_Assert( Ar.size() == Size(<span class="number">3</span>,<span class="number">3</span>) || Ar.size() == Size(<span class="number">4</span>, <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//LU分解求新的内参矩阵Ar与旋转矩阵R乘积的逆矩阵iR</span></span><br><span class="line">    Mat_&lt;<span class="keyword">double</span>&gt; iR = (Ar.colRange(<span class="number">0</span>,<span class="number">3</span>)*R).inv(DECOMP_LU);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span>* ir = &amp;iR(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从旧的内参矩阵中取出光心位置u0,v0,和归一化焦距fx,fy</span></span><br><span class="line">    <span class="keyword">double</span> u0 = A(<span class="number">0</span>, <span class="number">2</span>),  v0 = A(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">double</span> fx = A(<span class="number">0</span>, <span class="number">0</span>),  fy = A(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尼玛14个畸变系数，不过大多用到的只有(k1,k2,p1,p2)，最多加一个k3，用不到的置为0</span></span><br><span class="line">    CV_Assert( distCoeffs.size() == Size(<span class="number">1</span>, <span class="number">4</span>) || distCoeffs.size() == Size(<span class="number">4</span>, <span class="number">1</span>) ||</span><br><span class="line">               distCoeffs.size() == Size(<span class="number">1</span>, <span class="number">5</span>) || distCoeffs.size() == Size(<span class="number">5</span>, <span class="number">1</span>) ||</span><br><span class="line">               distCoeffs.size() == Size(<span class="number">1</span>, <span class="number">8</span>) || distCoeffs.size() == Size(<span class="number">8</span>, <span class="number">1</span>) ||</span><br><span class="line">               distCoeffs.size() == Size(<span class="number">1</span>, <span class="number">12</span>) || distCoeffs.size() == Size(<span class="number">12</span>, <span class="number">1</span>) ||</span><br><span class="line">               distCoeffs.size() == Size(<span class="number">1</span>, <span class="number">14</span>) || distCoeffs.size() == Size(<span class="number">14</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( distCoeffs.rows != <span class="number">1</span> &amp;&amp; !distCoeffs.isContinuous() )</span><br><span class="line">        distCoeffs = distCoeffs.t();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span>* <span class="keyword">const</span> distPtr = distCoeffs.ptr&lt;<span class="keyword">double</span>&gt;();</span><br><span class="line">    <span class="keyword">double</span> k1 = distPtr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">double</span> k2 = distPtr[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">double</span> p1 = distPtr[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">double</span> p2 = distPtr[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">double</span> k3 = distCoeffs.cols + distCoeffs.rows - <span class="number">1</span> &gt;= <span class="number">5</span> ? distPtr[<span class="number">4</span>] : <span class="number">0.</span>;</span><br><span class="line">    <span class="keyword">double</span> k4 = distCoeffs.cols + distCoeffs.rows - <span class="number">1</span> &gt;= <span class="number">8</span> ? distPtr[<span class="number">5</span>] : <span class="number">0.</span>;</span><br><span class="line">    <span class="keyword">double</span> k5 = distCoeffs.cols + distCoeffs.rows - <span class="number">1</span> &gt;= <span class="number">8</span> ? distPtr[<span class="number">6</span>] : <span class="number">0.</span>;</span><br><span class="line">    <span class="keyword">double</span> k6 = distCoeffs.cols + distCoeffs.rows - <span class="number">1</span> &gt;= <span class="number">8</span> ? distPtr[<span class="number">7</span>] : <span class="number">0.</span>;</span><br><span class="line">    <span class="keyword">double</span> s1 = distCoeffs.cols + distCoeffs.rows - <span class="number">1</span> &gt;= <span class="number">12</span> ? distPtr[<span class="number">8</span>] : <span class="number">0.</span>;</span><br><span class="line">    <span class="keyword">double</span> s2 = distCoeffs.cols + distCoeffs.rows - <span class="number">1</span> &gt;= <span class="number">12</span> ? distPtr[<span class="number">9</span>] : <span class="number">0.</span>;</span><br><span class="line">    <span class="keyword">double</span> s3 = distCoeffs.cols + distCoeffs.rows - <span class="number">1</span> &gt;= <span class="number">12</span> ? distPtr[<span class="number">10</span>] : <span class="number">0.</span>;</span><br><span class="line">    <span class="keyword">double</span> s4 = distCoeffs.cols + distCoeffs.rows - <span class="number">1</span> &gt;= <span class="number">12</span> ? distPtr[<span class="number">11</span>] : <span class="number">0.</span>;</span><br><span class="line">    <span class="keyword">double</span> tauX = distCoeffs.cols + distCoeffs.rows - <span class="number">1</span> &gt;= <span class="number">14</span> ? distPtr[<span class="number">12</span>] : <span class="number">0.</span>;</span><br><span class="line">    <span class="keyword">double</span> tauY = distCoeffs.cols + distCoeffs.rows - <span class="number">1</span> &gt;= <span class="number">14</span> ? distPtr[<span class="number">13</span>] : <span class="number">0.</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//tauX,tauY这个是什么梯形畸变，用不到的话matTilt为单位阵</span></span><br><span class="line">    <span class="comment">// Matrix for trapezoidal distortion of tilted image sensor</span></span><br><span class="line">    cv::Matx33d matTilt = cv::Matx33d::eye();</span><br><span class="line">    cv::detail::computeTiltProjectionMatrix(tauX, tauY, &amp;matTilt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size.height; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">float</span>* m1f = map1.ptr&lt;<span class="keyword">float</span>&gt;(i);</span><br><span class="line">        <span class="keyword">float</span>* m2f = map2.empty() ? <span class="number">0</span> : map2.ptr&lt;<span class="keyword">float</span>&gt;(i);</span><br><span class="line">        <span class="keyword">short</span>* m1 = (<span class="keyword">short</span>*)m1f;</span><br><span class="line">        ushort* m2 = (ushort*)m2f;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//利用逆矩阵iR将二维图像坐标(j,i)转换到摄像机坐标系(_x,_y,_w)</span></span><br><span class="line">        <span class="keyword">double</span> _x = i*ir[<span class="number">1</span>] + ir[<span class="number">2</span>], _y = i*ir[<span class="number">4</span>] + ir[<span class="number">5</span>], _w = i*ir[<span class="number">7</span>] + ir[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size.width; j++, _x += ir[<span class="number">0</span>], _y += ir[<span class="number">3</span>], _w += ir[<span class="number">6</span>] )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//摄像机坐标系归一化，令Z=1平面</span></span><br><span class="line">            <span class="keyword">double</span> w = <span class="number">1.</span>/_w, x = _x*w, y = _y*w;</span><br><span class="line">             <span class="comment">//这一部分请看OpenCV官方文档，畸变模型部分</span></span><br><span class="line">            <span class="keyword">double</span> x2 = x*x, y2 = y*y;</span><br><span class="line">            <span class="keyword">double</span> r2 = x2 + y2, _2xy = <span class="number">2</span>*x*y;</span><br><span class="line">            <span class="keyword">double</span> kr = (<span class="number">1</span> + ((k3*r2 + k2)*r2 + k1)*r2)/(<span class="number">1</span> + ((k6*r2 + k5)*r2 + k4)*r2);</span><br><span class="line">            <span class="keyword">double</span> xd = (x*kr + p1*_2xy + p2*(r2 + <span class="number">2</span>*x2) + s1*r2+s2*r2*r2);</span><br><span class="line">            <span class="keyword">double</span> yd = (y*kr + p1*(r2 + <span class="number">2</span>*y2) + p2*_2xy + s3*r2+s4*r2*r2);</span><br><span class="line">           <span class="comment">//根据求取的xd,yd将三维坐标重投影到二维畸变图像坐标(u,v)</span></span><br><span class="line">            cv::Vec3d vecTilt = matTilt*cv::Vec3d(xd, yd, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">double</span> invProj = vecTilt(<span class="number">2</span>) ? <span class="number">1.</span>/vecTilt(<span class="number">2</span>) : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">double</span> u = fx*invProj*vecTilt(<span class="number">0</span>) + u0;</span><br><span class="line">            <span class="keyword">double</span> v = fy*invProj*vecTilt(<span class="number">1</span>) + v0;</span><br><span class="line">            <span class="comment">//保存u,v的值到Mapx,Mapy中</span></span><br><span class="line">            <span class="keyword">if</span>( m1type == CV_16SC2 )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> iu = saturate_cast&lt;<span class="keyword">int</span>&gt;(u*INTER_TAB_SIZE);</span><br><span class="line">                <span class="keyword">int</span> iv = saturate_cast&lt;<span class="keyword">int</span>&gt;(v*INTER_TAB_SIZE);</span><br><span class="line">                m1[j*<span class="number">2</span>] = (<span class="keyword">short</span>)(iu &gt;&gt; INTER_BITS);</span><br><span class="line">                m1[j*<span class="number">2</span>+<span class="number">1</span>] = (<span class="keyword">short</span>)(iv &gt;&gt; INTER_BITS);</span><br><span class="line">                m2[j] = (ushort)((iv &amp; (INTER_TAB_SIZE<span class="number">-1</span>))*INTER_TAB_SIZE + (iu &amp; (INTER_TAB_SIZE<span class="number">-1</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>( m1type == CV_32FC1 )</span><br><span class="line">            &#123;</span><br><span class="line">                m1f[j] = (<span class="keyword">float</span>)u;</span><br><span class="line">                m2f[j] = (<span class="keyword">float</span>)v;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                m1f[j*<span class="number">2</span>] = (<span class="keyword">float</span>)u;</span><br><span class="line">                m1f[j*<span class="number">2</span>+<span class="number">1</span>] = (<span class="keyword">float</span>)v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">希望对需要的人能有所帮助，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="OPENCV" scheme="https://wordzzzz.github.io/categories/OPENCV/"/>
    
    
      <category term="OPENCV2" scheme="https://wordzzzz.github.io/tags/OPENCV2/"/>
    
      <category term="OPENCV3" scheme="https://wordzzzz.github.io/tags/OPENCV3/"/>
    
      <category term="畸变校正" scheme="https://wordzzzz.github.io/tags/%E7%95%B8%E5%8F%98%E6%A0%A1%E6%AD%A3/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记（递归）：valid-palindrome</title>
    <link href="https://wordzzzz.github.io/2018/01/26/Recursive/"/>
    <id>https://wordzzzz.github.io/2018/01/26/Recursive/</id>
    <published>2018-01-25T16:00:00.000Z</published>
    <updated>2018-01-26T13:41:18.306Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/LeetCode" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/LeetCode</a></strong></li><li><strong>刷题平台：<a href="https://www.nowcoder.com/ta/leetcode" target="_blank" rel="noopener">https://www.nowcoder.com/ta/leetcode</a></strong></li><li><strong>题&emsp;&emsp;库：Leetcode经典编程题</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><p>[toc]</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.</p><p>For example,<br>“A man, a plan, a canal: Panama”is a palindrome.<br>“race a car”is not a palindrome.</p><p>Note:<br>Have you consider that the string might be empty? This is a good question to ask during an interview.</p><p>For the purpose of this problem, we define empty string as valid palindrome.</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>额，判断字符串是否为回文，这道题貌似没什么好说的，需要注意的是空字符串也算回文哦。</p><p>从两边开始遍历字符串，如果遇到非数字字符的就跳过，然后比较当前两个字符是否相等；相等就进入下一个循环，否则返回false。</p><h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.size() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = s.size() - <span class="number">1</span>; i &lt; j; ++i, --j)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; !<span class="built_in">isalnum</span>(s[i]))</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; !<span class="built_in">isalnum</span>(s[j]))</span><br><span class="line">                j--;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; j &amp;&amp; <span class="built_in">tolower</span>(s[i]) != <span class="built_in">tolower</span>(s[j]))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindromeCore</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt;= end)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(start &lt; end &amp;&amp; !<span class="built_in">isalnum</span>(s[start]))</span><br><span class="line">            start++;</span><br><span class="line">        <span class="keyword">while</span>(start &lt; end &amp;&amp; !<span class="built_in">isalnum</span>(s[end]))</span><br><span class="line">            end--;</span><br><span class="line">        <span class="keyword">if</span>(start &lt; end &amp;&amp; <span class="built_in">tolower</span>(s[start]) != <span class="built_in">tolower</span>(s[end]))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isPalindromeCore(s, ++start, --end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.size() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> isPalindromeCore(s, <span class="number">0</span>, s.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/tags/Leetcode/"/>
    
      <category term="Recursive" scheme="https://wordzzzz.github.io/tags/Recursive/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记（贪心）：gas-station</title>
    <link href="https://wordzzzz.github.io/2018/01/26/Greedy1/"/>
    <id>https://wordzzzz.github.io/2018/01/26/Greedy1/</id>
    <published>2018-01-25T16:00:00.000Z</published>
    <updated>2018-01-26T13:41:55.145Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/LeetCode" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/LeetCode</a></strong></li><li><strong>刷题平台：<a href="https://www.nowcoder.com/ta/leetcode" target="_blank" rel="noopener">https://www.nowcoder.com/ta/leetcode</a></strong></li><li><strong>题&emsp;&emsp;库：Leetcode经典编程题</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><p>[toc]</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>There are N gas stations along a circular route, where the amount of gas at station i isgas[i].</p><p>You have a car with an unlimited gas tank and it costscost[i]of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.</p><p>Return the starting gas station’s index if you can travel around the circuit once, otherwise return -1.</p><p>Note:<br>The solution is guaranteed to be unique.</p><p>沿着一个圆形的路线有N个加油站，那里的加油站的天然气数量是gas [i]。 你有一辆带有无限制燃气罐的汽车，从车站i到下一站（i + 1）需要花费天然气。 你从一个加油站开始，开始时邮箱为空。 如果您可以在电路上巡回一次，则返回启动加油站的索引，否则返回-1。 注意：解决方案保证是唯一的。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>从start出发，如果油量足够，可以一直向后走end++；油量不够的时候，<br>start向后退，最终start == end的时候，如果有解一定是当前start所在位置。</p><p>因为是个环，所以我们将最后一个元素设置为起点，第一个元素设置为start下一点，这样可以用统一的判断条件start &lt; end来作为循环的条件，当start和end两者相等时，循环结束。</p><h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;gas, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(gas.size() &lt;= <span class="number">0</span> || cost.size() &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> start = gas.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = gas[start] - cost[start];</span><br><span class="line">        <span class="keyword">while</span>(start &gt; end)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                sum += gas[end] - cost[end];</span><br><span class="line">                ++end;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                --start;</span><br><span class="line">                sum += gas[start] - cost[start];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum &gt;= <span class="number">0</span> ? start : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/tags/Leetcode/"/>
    
      <category term="Greedy" scheme="https://wordzzzz.github.io/tags/Greedy/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记（贪心）：minimum-window-substring</title>
    <link href="https://wordzzzz.github.io/2018/01/26/Greedy3/"/>
    <id>https://wordzzzz.github.io/2018/01/26/Greedy3/</id>
    <published>2018-01-25T16:00:00.000Z</published>
    <updated>2018-01-26T13:42:52.897Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/LeetCode" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/LeetCode</a></strong></li><li><strong>刷题平台：<a href="https://www.nowcoder.com/ta/leetcode" target="_blank" rel="noopener">https://www.nowcoder.com/ta/leetcode</a></strong></li><li><strong>题&emsp;&emsp;库：Leetcode经典编程题</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><p>[toc]</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).</p><p>For example,<br>S =”ADOBECODEBANC”<br>T =”ABC”</p><p>Minimum window is”BANC”.</p><p>Note:<br>If there is no such window in S that covers all characters in T, return the emtpy string””.</p><p>If there are multiple such windows, you are guaranteed that there will always be only one unique minimum window in S.</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这道题被自己的无知给坑了，在java里面传人substring的两个参数分别是截取字符串起始位置和截止位置，在本题中应该写成substring(head, head+d);在C++里面传人substr的两个参数分别是截取字符串起始位置和截取字符串长度，在本题中应该写成substr(head, d)。</p><p>这道题的思路是：</p><ul><li>begin开始指向0， end一直后移，直到begin - end区间包含T中所有字符。<br>记录窗口长度d</li><li>然后begin开始后移移除元素，直到移除的字符是T中的字符则停止，此时T中有一个字符没被<br>包含在窗口，<br>继续后移end，直到T中的所有字符被包含在窗口，重新记录最小的窗口d。</li><li>如此循环知道end到S中的最后一个字符。<br>时间复杂度为O(n)</li></ul><p>下面贴一下大神的模板，对于大多数子字符串问题，我们给了一个字符串，并且需要找到满足一些限制的子字符串。一般的方法是使用两个指针辅助的hashmap。模板如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findSubstring</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">map</span>(<span class="number">128</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> counter; <span class="comment">// check whether the substring is valid</span></span><br><span class="line">        <span class="keyword">int</span> begin=<span class="number">0</span>, end=<span class="number">0</span>; <span class="comment">//two pointers, one point to tail and one  head</span></span><br><span class="line">        <span class="keyword">int</span> d; <span class="comment">//the length of substring</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>() &#123; <span class="comment">/* initialize the hash map here */</span> &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(end &lt; s.size())&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>[s[end++]]-- ?)&#123;  <span class="comment">/* modify counter here */</span> &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(<span class="comment">/* counter condition */</span>)&#123; </span><br><span class="line">                 </span><br><span class="line">                 <span class="comment">/* update d here if finding minimum*/</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//increase begin to make it invalid/valid again</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">map</span>[s[begin++]]++ ?)&#123; <span class="comment">/*modify counter here*/</span> &#125;</span><br><span class="line">            &#125;  </span><br><span class="line"></span><br><span class="line">            <span class="comment">/* update d here if finding maximum*/</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>有一点需要提到的是，当要求查找最大子字符串时，我们应该在内部while循环之后更新最大值，以保证子字符串是有效的。另一方面，当要求查找最小子字符串时，我们应该更新内部while循环内的最小值。</p><p>解决最多两个不同字符的最长子字符串的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstringTwoDistinct</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">map</span>(<span class="number">128</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> counter=<span class="number">0</span>, begin=<span class="number">0</span>, end=<span class="number">0</span>, d=<span class="number">0</span>; </span><br><span class="line">        <span class="keyword">while</span>(end &lt; s.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>[s[end++]]++ == <span class="number">0</span>) counter++;</span><br><span class="line">            <span class="keyword">while</span>(counter &gt; <span class="number">2</span>) <span class="keyword">if</span>(<span class="built_in">map</span>[s[begin++]]-- == <span class="number">1</span>) counter--;</span><br><span class="line">            d = max(d, end - begin);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>解决最长子字符串不重复字符的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">map</span>(<span class="number">128</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> counter=<span class="number">0</span>, begin=<span class="number">0</span>, end=<span class="number">0</span>, d=<span class="number">0</span>; </span><br><span class="line">        <span class="keyword">while</span>(end &lt; s.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>[s[end++]]++ &gt; <span class="number">0</span>) counter++; </span><br><span class="line">            <span class="keyword">while</span>(counter&gt;<span class="number">0</span>) <span class="keyword">if</span>(<span class="built_in">map</span>[s[begin++]]-- &gt; <span class="number">1</span>) counter--;</span><br><span class="line">            d=max(d, end - begin); <span class="comment">//while valid, update d</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">map</span>(<span class="number">128</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c: t) <span class="built_in">map</span>[c]++;</span><br><span class="line">        <span class="keyword">int</span> counter = t.size(), begin = <span class="number">0</span>, end = <span class="number">0</span>, d = INT_MAX, head = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(end &lt; s.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>[s[end++]]-- &gt;<span class="number">0</span>) counter--; <span class="comment">//in t</span></span><br><span class="line">            <span class="keyword">while</span>(counter == <span class="number">0</span>)&#123; <span class="comment">//valid</span></span><br><span class="line">                <span class="keyword">if</span>(end - begin &lt; d)  d = end - (head = begin);</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">map</span>[s[begin++]]++ == <span class="number">0</span>) counter++;  <span class="comment">//make it invalid</span></span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> d == INT_MAX? <span class="string">""</span>:s.substr(head, d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.com/problems/minimum-window-substring/discuss/26808" target="_blank" rel="noopener">参考链接：minimum-window-substring</a></p><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/tags/Leetcode/"/>
    
      <category term="Greedy" scheme="https://wordzzzz.github.io/tags/Greedy/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记（贪心）：maximal-rectangle</title>
    <link href="https://wordzzzz.github.io/2018/01/26/Greedy2/"/>
    <id>https://wordzzzz.github.io/2018/01/26/Greedy2/</id>
    <published>2018-01-25T16:00:00.000Z</published>
    <updated>2018-01-26T13:42:23.580Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/LeetCode" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/LeetCode</a></strong></li><li><strong>刷题平台：<a href="https://www.nowcoder.com/ta/leetcode" target="_blank" rel="noopener">https://www.nowcoder.com/ta/leetcode</a></strong></li><li><strong>题&emsp;&emsp;库：Leetcode经典编程题</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><p>[toc]</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest rectangle containing all ones and return its area.</p><p>给定一个用0和1填充的2D二进制矩阵，找到包含所有1的最大矩形并返回其面积。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>刚看到这道题的时候，一脸无奈。我们还是先来看一下Largest Rectangle in Histogram这道题目吧。</p><h3 id="Largest-Rectangle-in-Histogram"><a href="#Largest-Rectangle-in-Histogram" class="headerlink" title="Largest Rectangle in Histogram"></a>Largest Rectangle in Histogram</h3><p>Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.</p><p>Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3].</p><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20180126101534175?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><br><p></p><p>The largest rectangle is shown in the shaded area, which has area = 10 unit.</p><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20180126101634504?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><br><p></p><p>For example,<br>Given heights = [2,1,5,6,2,3],<br>return 10.</p><p>我们先把代码贴出来，然后边看代码边捋清思路。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        height.push_back(<span class="number">0</span>);<span class="comment">//追加一个零用来做终止条件。</span></span><br><span class="line">        <span class="keyword">int</span> maxSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">while</span>(i &lt; height.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.empty() || height[i] &gt;= height[s.top()])</span><br><span class="line">                s.push(i++);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> cur = height[s.top()];</span><br><span class="line">                s.pop();</span><br><span class="line">                maxSize = max(maxSize, cur * (s.empty() ? i : i - <span class="number">1</span> - s.top()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>首先，我们需要新建stack来保存遍历过程中的递增序列。如果栈是空的，那么索引i入栈。所以当i=0时，将0入栈。注意栈内保存的是索引，不是高度。然后i++。</li></ul><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20180126110920004?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><br><p></p><ul><li>当i=1的时候，发现height[i]小于了栈内的元素，于是出栈。这时候stack为空，所以面积的计算是height[t] * i。t是刚刚弹出的stack顶元素。也就是蓝色部分的面积。</li></ul><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20180126111432408?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><br><p></p><ul><li>这时候stack为空了，那就继续入栈。注意到只要是连续递增的序列，我们都要keep pushing，直到我们遇到了i=4，height[i]=2小于了栈顶的元素。</li></ul><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20180126111452015?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><br><p></p><ul><li>这时候开始计算矩形面积。首先弹出栈顶元素，t=3。即下图绿色部分。</li></ul><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20180126111528463?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><br><p></p><ul><li>接下来注意到栈顶的（索引指向的）元素还是大于当前i指向的元素，于是出栈，并继续计算面积，桃红色部分。</li></ul><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20180126111658101?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><br><p></p><ul><li>最后，栈顶的（索引指向的）元素大于了当前i指向的元素，循环继续，入栈并推动i前进。直到我们再次遇到下降的元素，也就是我们最后人为添加的dummy元素0.</li></ul><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20180126111715452?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><br><p></p><ul><li>同理，我们计算栈内的面积。由于当前i是最小元素，所以所有的栈内元素都要被弹出并参与面积计算。</li></ul><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20180126111731018?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><br><p></p><p>注意我们在计算面积的时候已经更新过了maxSize 。</p><p>我们可以看到，stack中总是保持递增的元素的索引，然后当遇到较小的元素后，依次出栈并计算栈中bar能围成的面积，直到栈中元素小于当前元素。</p><h3 id="maximal-rectangle"><a href="#maximal-rectangle" class="headerlink" title="maximal-rectangle"></a>maximal-rectangle</h3><p>这道题的解法灵感来自于Largest Rectangle in Histogram这道题，假设我们把矩阵沿着某一行切下来，然后把切的行作为底面，将自底面往上的矩阵看成一个直方图（histogram）。直方图的中每个项的高度就是从底面行开始往上1的数量。根据Largest Rectangle in Histogram中的largestRectangleArea函数我们就可以求出当前行作为矩阵下边缘的一个最大矩阵。接下来如果对每一行都做一次Largest Rectangle in Histogram，从其中选出最大的矩阵，那么它就是整个矩阵中面积最大的子矩阵。算法时间复杂度为O(m*n)，这解法真是太棒了，其实应该算是动态规划的题目了。</p><h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        height.push_back(<span class="number">0</span>);<span class="comment">//追加一个零用来做终止条件。</span></span><br><span class="line">        <span class="keyword">int</span> maxSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">while</span>(i &lt; height.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.empty() || height[i] &gt;= height[s.top()])</span><br><span class="line">                s.push(i++);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> cur = height[s.top()];</span><br><span class="line">                s.pop();</span><br><span class="line">                maxSize = max(maxSize, cur * (s.empty() ? i : i - <span class="number">1</span> - s.top()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &gt; &amp;matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxRec = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; height(matrix[<span class="number">0</span>].size(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].size(); ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="string">'1'</span>)<span class="comment">//这里的数字1一定要加单引号哦~</span></span><br><span class="line">                    height[j]++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    height[j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            maxRec = max(maxRec, largestRectangleArea(height));<span class="comment">//对每一行都求一次最大值，而不是只有最后一行。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxRec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="http://www.cnblogs.com/lichen782/p/leetcode_Largest_Rectangle_in_Histogram.html" target="_blank" rel="noopener">参考链接</a></p><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/tags/Leetcode/"/>
    
      <category term="Greedy" scheme="https://wordzzzz.github.io/tags/Greedy/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记（链表）：swap-nodes-in-pairs</title>
    <link href="https://wordzzzz.github.io/2018/01/22/LIST2/"/>
    <id>https://wordzzzz.github.io/2018/01/22/LIST2/</id>
    <published>2018-01-21T16:00:00.000Z</published>
    <updated>2018-01-22T03:10:10.036Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/LeetCode" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/LeetCode</a></strong></li><li><strong>刷题平台：<a href="https://www.nowcoder.com/ta/leetcode" target="_blank" rel="noopener">https://www.nowcoder.com/ta/leetcode</a></strong></li><li><strong>题&emsp;&emsp;库：Leetcode经典编程题</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><p>[toc]</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a linked list, swap every two adjacent nodes and return its head.</p><p>For example,<br>Given1-&gt;2-&gt;3-&gt;4, you should return the list as2-&gt;1-&gt;4-&gt;3.</p><p>Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed.</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>通过这么多次的编程练习，链表的顺序交换我相信大家早已轻车熟路。本题中，我们先写一个交换相邻结点的函数swap，此函数交换输入的两个相邻链表结点之后，返回新的第一结点。然后我们开始考虑主函数，同样的新建一个指向头结点的指针（只要头结点有可能被替换，我们既需要这么做），然后遍历整个链表调用交换函数swap即可。</p><h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">swap</span><span class="params">(ListNode *slow, ListNode *fast)</span></span>&#123;</span><br><span class="line">        slow-&gt;next = fast-&gt;next;</span><br><span class="line">        fast-&gt;next = slow;</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode *<span class="title">swapPairs</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        ListNode *cur = dummy;</span><br><span class="line">        <span class="keyword">for</span>(;cur-&gt;next != <span class="literal">NULL</span> &amp;&amp; cur-&gt;next-&gt;next != <span class="literal">NULL</span>; cur = cur-&gt;next-&gt;next)</span><br><span class="line">            cur-&gt;next = swap(cur-&gt;next, cur-&gt;next-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/tags/Leetcode/"/>
    
      <category term="List" scheme="https://wordzzzz.github.io/tags/List/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记（链表）：remove-nth-node-from-end-of-list</title>
    <link href="https://wordzzzz.github.io/2018/01/22/LIST4/"/>
    <id>https://wordzzzz.github.io/2018/01/22/LIST4/</id>
    <published>2018-01-21T16:00:00.000Z</published>
    <updated>2018-01-22T03:12:03.256Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/LeetCode" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/LeetCode</a></strong></li><li><strong>刷题平台：<a href="https://www.nowcoder.com/ta/leetcode" target="_blank" rel="noopener">https://www.nowcoder.com/ta/leetcode</a></strong></li><li><strong>题&emsp;&emsp;库：Leetcode经典编程题</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><p>[toc]</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a linked list, remove the n th node from the end of list and return its head.</p><p>For example,</p><p>   Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.</p><p>   After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.<br>Note:<br>Given n will always be valid.<br>Try to do this in one pass.</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>删除倒数第n个结点，我们就需要找到倒数第n个结点。于是，我们可以利用快慢指针来实现。</p><p>首先，fast走n步指向第n个结点；接着，fast和slow一起走，直到fast指向尾结点；最后，删除元素（这里需要注意的是加入pre来判断删除元素是否为头结点）。</p><h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">removeNthFromEnd</span><span class="params">(ListNode *head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode *slow = head;</span><br><span class="line">        ListNode *fast = head;</span><br><span class="line">        ListNode *pre = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//fast先走n步，到达第n个结点</span></span><br><span class="line">        <span class="keyword">while</span>(--n)</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        <span class="comment">//fast和slow一起走，直到fast走到链表尾部</span></span><br><span class="line">        <span class="keyword">while</span>(fast-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            pre = slow;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此处用于判断删除的结点是否为头结点</span></span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="literal">NULL</span>)</span><br><span class="line">            pre-&gt;next = slow-&gt;next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/tags/Leetcode/"/>
    
      <category term="List" scheme="https://wordzzzz.github.io/tags/List/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记（链表）：add-two-numbers</title>
    <link href="https://wordzzzz.github.io/2018/01/22/LIST5/"/>
    <id>https://wordzzzz.github.io/2018/01/22/LIST5/</id>
    <published>2018-01-21T16:00:00.000Z</published>
    <updated>2018-01-22T03:13:11.020Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/LeetCode" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/LeetCode</a></strong></li><li><strong>刷题平台：<a href="https://www.nowcoder.com/ta/leetcode" target="_blank" rel="noopener">https://www.nowcoder.com/ta/leetcode</a></strong></li><li><strong>题&emsp;&emsp;库：Leetcode经典编程题</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><p>[toc]</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p><p>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>Output: 7 -&gt; 0 -&gt; 8</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>两个链表求和，需要考虑进位问题。</p><p>首先新建链表，用于存储求和之后的结点；循环的终止条件是，直到l1或l2都为空且进位标志位为0；循环内，每次都进行求和运算和更新head的值。</p><p>在求carry的时候我们采用判断而不是除法，这一点大家需要注意，并且在以后的程序设计中也要尽量较少乘除法这种比较耗时的运算操作。</p><h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">addTwoNumbers</span><span class="params">(ListNode *l1, ListNode *l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="literal">NULL</span> || l2 == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> (l1 == <span class="literal">NULL</span>) ? l2 : l1;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;                      <span class="comment">//进位</span></span><br><span class="line">        <span class="keyword">int</span> sum;                            <span class="comment">//求和</span></span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> ListNode (<span class="number">0</span>); <span class="comment">//新建链表</span></span><br><span class="line">        ListNode *head = dummy;</span><br><span class="line">        <span class="keyword">while</span>(l1 || l2 || carry)&#123;</span><br><span class="line">            sum = (l1 ? l1-&gt;val : <span class="number">0</span>) + (l2 ? l2-&gt;val : <span class="number">0</span>) + carry;</span><br><span class="line">            ListNode *cur = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">            carry = (sum &gt;= <span class="number">10</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            head-&gt;next = cur;</span><br><span class="line">            head = cur;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(l1) l1 = l1-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(l2) l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/tags/Leetcode/"/>
    
      <category term="List" scheme="https://wordzzzz.github.io/tags/List/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记（链表）：merge-k-sorted-lists</title>
    <link href="https://wordzzzz.github.io/2018/01/22/LIST3/"/>
    <id>https://wordzzzz.github.io/2018/01/22/LIST3/</id>
    <published>2018-01-21T16:00:00.000Z</published>
    <updated>2018-01-22T03:11:07.273Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/LeetCode" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/LeetCode</a></strong></li><li><strong>刷题平台：<a href="https://www.nowcoder.com/ta/leetcode" target="_blank" rel="noopener">https://www.nowcoder.com/ta/leetcode</a></strong></li><li><strong>题&emsp;&emsp;库：Leetcode经典编程题</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><p>[toc]</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>之前做过一道题是对两个排序链表进行合并，这次是k个。所以，需要在原来的基础长做一些封装。</p><p>按照归并排序的思想，我们通过二分法得到中点进行递归，自下而上进行两两归并，直到只剩最后一个链表。</p><h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode *&gt; &amp;lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lists.size() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> mergeList(lists, <span class="number">0</span>, lists.size()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode *<span class="title">mergeList</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode *&gt; &amp;lists, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(high &lt;= low)</span><br><span class="line">            <span class="keyword">return</span> lists[low];</span><br><span class="line">        <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        ListNode *left = mergeList(lists, low, mid);</span><br><span class="line">        ListNode *right = mergeList(lists, mid+<span class="number">1</span>, high);</span><br><span class="line">        <span class="keyword">return</span> merge(left, right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode *<span class="title">merge</span><span class="params">(ListNode *left, ListNode *right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">if</span>(right == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        </span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode *cur = dummy;</span><br><span class="line">        <span class="keyword">while</span>(left != <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(left-&gt;val &lt; right-&gt;val)&#123;</span><br><span class="line">                cur-&gt;next = left;</span><br><span class="line">                left = left-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cur-&gt;next = right;</span><br><span class="line">                right = right-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = left ? left : right;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/tags/Leetcode/"/>
    
      <category term="List" scheme="https://wordzzzz.github.io/tags/List/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记（链表）：reverse-nodes-in-k-group</title>
    <link href="https://wordzzzz.github.io/2018/01/22/LIST1/"/>
    <id>https://wordzzzz.github.io/2018/01/22/LIST1/</id>
    <published>2018-01-21T16:00:00.000Z</published>
    <updated>2018-01-22T03:09:28.469Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/LeetCode" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/LeetCode</a></strong></li><li><strong>刷题平台：<a href="https://www.nowcoder.com/ta/leetcode" target="_blank" rel="noopener">https://www.nowcoder.com/ta/leetcode</a></strong></li><li><strong>题&emsp;&emsp;库：Leetcode经典编程题</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><p>[toc]</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.</p><p>If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.</p><p>You may not alter the values in the nodes, only nodes itself may be changed.</p><p>Only constant memory is allowed.</p><p>For example,<br>Given this linked list:1-&gt;2-&gt;3-&gt;4-&gt;5；</p><p>For k = 2, you should return:2-&gt;1-&gt;4-&gt;3-&gt;5</p><p>For k = 3, you should return:3-&gt;2-&gt;1-&gt;4-&gt;5</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>解法有两种，一种是申请额外空间来依次对k个元素进行排序，时间复杂度O(n)，空间复杂度O(k)。另一种是在原链表中进行反转，不需要额外空间，所以算法复杂度为O(n)，空间复杂度为O(1)。</p><p>本文中对第二种解法进行详细的讲解。</p><ul><li>首先，单个链表的反转我想大家肯定都会，那就是遍历链表，每遇见一个结点就扔到第一位。因为涉及到第一个结点的操作，所以我们一定要有指向第一个结点的指针，这里在传参的时候需要注意。</li><li>接下来，我们采用整除来每次提取k个结点。需要注意的同样是参数的传递，怎么对接自己得把握好。就拿例题中的题目（list:1-&gt;2-&gt;3-&gt;4-&gt;5；k=3）来说，我的代码传入reverseList的参数应该是指向1的上一个结点的指针和指向4的指针。</li><li>最后，贴代码呗。</li></ul><h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode *<span class="title">reverseList</span><span class="params">(ListNode *slow, ListNode *fast)</span></span>&#123;</span><br><span class="line">        ListNode *last = slow-&gt;next;</span><br><span class="line">        ListNode *cur = last-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(cur != fast)&#123;</span><br><span class="line">            last-&gt;next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = slow-&gt;next;</span><br><span class="line">            slow-&gt;next = cur;</span><br><span class="line">            cur = last-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode *<span class="title">reverseKGroup</span><span class="params">(ListNode *head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span> || k == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        ListNode *slow = dummy;</span><br><span class="line">        ListNode *fast = head;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span>(i % k == <span class="number">0</span>)&#123;</span><br><span class="line">                slow = reverseList(slow, fast-&gt;next);</span><br><span class="line">                fast = slow-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/tags/Leetcode/"/>
    
      <category term="List" scheme="https://wordzzzz.github.io/tags/List/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记（链表）：median-of-two-sorted-arrays</title>
    <link href="https://wordzzzz.github.io/2018/01/22/LIST6/"/>
    <id>https://wordzzzz.github.io/2018/01/22/LIST6/</id>
    <published>2018-01-21T16:00:00.000Z</published>
    <updated>2018-01-22T03:14:00.693Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/LeetCode" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/LeetCode</a></strong></li><li><strong>刷题平台：<a href="https://www.nowcoder.com/ta/leetcode" target="_blank" rel="noopener">https://www.nowcoder.com/ta/leetcode</a></strong></li><li><strong>题&emsp;&emsp;库：Leetcode经典编程题</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><p>[toc]</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>There are two sorted arrays A and B of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>要求在O(log (m+n))时间内找到中位数，所以像那些合并之后再二分查找、或者一边比较一边合并到总量一半的方法肯定是不行的。</p><p>我们可以将原问题转变成一个寻找第k小数的问题（假设两个原序列升序排列），这样中位数实际上是第(m+n)/2小的数。所以只要解决了第k小数的问题，原问题也得以解决。</p><p>首先假设数组A和B的元素个数都大于k/2，我们比较A[k/2-1]和B[k/2-1]两个元素，这两个元素分别表示A的第k/2小的元素和B的第k/2小的元素。这两个元素比较共有三种情况：&gt;、&lt;和=。如果A[k/2-1] &lt; B[k/2-1]，这表示A[0]到A[k/2-1]的元素都在A和B合并之后的前k小的元素中。换句话说，A[k/2-1]不可能大于两数组合并之后的第k小值，所以我们可以将其抛弃。</p><p>当A[k/2-1]=B[k/2-1]时，我们已经找到了第k小的数，也即这个相等的元素，我们将其记为m。由于在A和B中分别有k/2-1个元素小于m，所以m即是第k小的数。(这里可能有人会有疑问，如果k为奇数，则m不是中位数。这里是进行了理想化考虑，在实际代码中略有不同，是先求k/2，然后利用k-k/2获得另一个数。)</p><p>通过上面的分析，我们即可以采用递归的方式实现寻找第k小的数。此外我们还需要考虑几个边界条件：</p><ul><li>如果A或者B为空，则直接返回B[k-1]或者A[k-1]；</li><li>如果k为1，我们只需要返回A[0]和B[0]中的较小值；</li><li>如果A[k/2-1]=B[k/2-1]，返回其中一个；</li></ul><h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findKth</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> m, <span class="keyword">int</span> B[], <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m &gt; n)</span><br><span class="line">            <span class="keyword">return</span> findKth(B, n, A, m, k);  <span class="comment">//始终保持元素较少的数组位于前面的位置</span></span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> B[k<span class="number">-1</span>];                  <span class="comment">//如果位于前面的数组为空，则直接返回后面数组的第k-1个元素</span></span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> min(A[<span class="number">0</span>], B[<span class="number">0</span>]);         <span class="comment">//如果k等于1，则返回两个数组头元素的最小值</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> pa = min(k / <span class="number">2</span>, m), pb = k - pa;</span><br><span class="line">        <span class="keyword">if</span>(A[pa<span class="number">-1</span>] &lt; B[pb<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">return</span> findKth(A + pa, m - pa, B, n, k - pa);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(A[pa - <span class="number">1</span>] &gt; B[pb - <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> findKth(A, m, B + pb, n - pb, k - pb);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> A[pa<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> m, <span class="keyword">int</span> B[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> total = m + n;</span><br><span class="line">        <span class="keyword">if</span>(total &amp; <span class="number">0x1</span>)</span><br><span class="line">            <span class="keyword">return</span> findKth(A, m, B, n, total / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> (findKth(A, m, B, n, total/<span class="number">2</span>)</span><br><span class="line">                   + findKth(A, m, B, n, total / <span class="number">2</span> + <span class="number">1</span>)) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/tags/Leetcode/"/>
    
      <category term="List" scheme="https://wordzzzz.github.io/tags/List/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记（链表）：remove-duplicates-from-sorted-list</title>
    <link href="https://wordzzzz.github.io/2018/01/17/LIST1/"/>
    <id>https://wordzzzz.github.io/2018/01/17/LIST1/</id>
    <published>2018-01-16T16:00:00.000Z</published>
    <updated>2018-01-17T03:09:34.419Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/LeetCode" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/LeetCode</a></strong></li><li><strong>刷题平台：<a href="https://www.nowcoder.com/ta/leetcode" target="_blank" rel="noopener">https://www.nowcoder.com/ta/leetcode</a></strong></li><li><strong>题&emsp;&emsp;库：Leetcode经典编程题</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><p>[toc]</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a sorted linked list, delete all duplicates such that each element appear only once.</p><p>For example,<br>Given1-&gt;1-&gt;2, return1-&gt;2.<br>Given1-&gt;1-&gt;2-&gt;3-&gt;3, return1-&gt;2-&gt;3.</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>简单问题不要想的太复杂，直接嵌套循环搞定喽。外循环用来遍历链表，内循环用来遍历重复元素，如果重复就一直传递指针。</p><h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">deleteDuplicates</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *dummy = head;</span><br><span class="line">        <span class="keyword">while</span>(dummy != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(dummy-&gt;next != <span class="literal">NULL</span> &amp;&amp; dummy-&gt;val == dummy-&gt;next-&gt;val)&#123;</span><br><span class="line">                dummy-&gt;next = dummy-&gt;next-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            dummy = dummy-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/tags/Leetcode/"/>
    
      <category term="List" scheme="https://wordzzzz.github.io/tags/List/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记（链表）：rotate-list</title>
    <link href="https://wordzzzz.github.io/2018/01/17/LIST4/"/>
    <id>https://wordzzzz.github.io/2018/01/17/LIST4/</id>
    <published>2018-01-16T16:00:00.000Z</published>
    <updated>2018-01-17T03:11:04.806Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/LeetCode" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/LeetCode</a></strong></li><li><strong>刷题平台：<a href="https://www.nowcoder.com/ta/leetcode" target="_blank" rel="noopener">https://www.nowcoder.com/ta/leetcode</a></strong></li><li><strong>题&emsp;&emsp;库：Leetcode经典编程题</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><p>[toc]</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a list, rotate the list to the right by k places, where k is non-negative.</p><p>For example:<br>Given1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULLand k =2,<br>return4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL.</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li>遍历链表得到链表长度并定位fast到尾结点；</li><li>根据链表长度，slow找到新的尾结点，slow的下一个结点便是新的头结点因为k可能比len大，所以需要取余数；</li><li>原先的尾结点与原先的头节点相连，dummy的next指针更新指向新的头结点，同时断开新的尾节点与新的头结点之间的联系。</li></ul><h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">rotateRight</span><span class="params">(ListNode *head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span> || head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        ListNode *fast = head;</span><br><span class="line">        ListNode *slow = head;</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="comment">//计算链表长度，同时fast指向尾结点</span></span><br><span class="line">        <span class="keyword">for</span>(len = <span class="number">1</span>; fast-&gt;next != <span class="literal">NULL</span>; ++len)</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        <span class="comment">//根据得到的链表长度，找到需要切开的结点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len - k % len; ++i)</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        fast-&gt;next = dummy-&gt;next;   <span class="comment">//尾结点连接到头节点，形成环状链表</span></span><br><span class="line">        dummy-&gt;next = slow-&gt;next;   <span class="comment">//fast的下一个结点作为新的头结点</span></span><br><span class="line">        slow-&gt;next = <span class="literal">NULL</span>;          <span class="comment">//slow结点和新的头结点断开</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/tags/Leetcode/"/>
    
      <category term="List" scheme="https://wordzzzz.github.io/tags/List/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记（链表）：merge-two-sorted-lists</title>
    <link href="https://wordzzzz.github.io/2018/01/17/LIST3/"/>
    <id>https://wordzzzz.github.io/2018/01/17/LIST3/</id>
    <published>2018-01-16T16:00:00.000Z</published>
    <updated>2018-01-17T03:10:34.492Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/LeetCode" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/LeetCode</a></strong></li><li><strong>刷题平台：<a href="https://www.nowcoder.com/ta/leetcode" target="_blank" rel="noopener">https://www.nowcoder.com/ta/leetcode</a></strong></li><li><strong>题&emsp;&emsp;库：Leetcode经典编程题</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><p>[toc]</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这道题剑指offer上应该也是有的，我就不去翻了。既然已经排序了，事情就变得简单多了，自下而上的归并排序的最后一步嘛~我们还是申请个新的结点，然后直接遍历两个链表元素比大小就好。</p><p>需要注意的是循环的终止条件，循环结束后还要把剩下的链表追加到cur的屁股后面哦。</p><h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">mergeTwoLists</span><span class="params">(ListNode *l1, ListNode *l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(l2 == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        </span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode *cur = dummy;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">NULL</span> &amp;&amp; l2 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)&#123;</span><br><span class="line">                cur-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cur-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = l1 ? l1 : l2;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/tags/Leetcode/"/>
    
      <category term="List" scheme="https://wordzzzz.github.io/tags/List/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记（链表）：remove-duplicates-from-sorted-list-ii</title>
    <link href="https://wordzzzz.github.io/2018/01/17/LIST2/"/>
    <id>https://wordzzzz.github.io/2018/01/17/LIST2/</id>
    <published>2018-01-16T16:00:00.000Z</published>
    <updated>2018-01-17T03:10:06.059Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/LeetCode" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/LeetCode</a></strong></li><li><strong>刷题平台：<a href="https://www.nowcoder.com/ta/leetcode" target="_blank" rel="noopener">https://www.nowcoder.com/ta/leetcode</a></strong></li><li><strong>题&emsp;&emsp;库：Leetcode经典编程题</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><p>[toc]</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.</p><p>For example,<br>Given1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5, return1-&gt;2-&gt;5.<br>Given1-&gt;1-&gt;1-&gt;2-&gt;3, return2-&gt;3.</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>因为第一个元素就有可能是重复节点，所以我们需要新建一个头节点指针，这一点在之前的几道题都有提到过。然后设置快慢指针，fast从head开始遍历，slow总是比fast慢一步；如果fast当前元素和它的下一个元素不相等，则更新slow、fast；否则，遍历重复元素，直到fast落到最后一个重复元素上，然后更新slow（跳过重复节点，直接指向fast的下一个节点）、fast。</p><h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">deleteDuplicates</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        ListNode *fast = head;</span><br><span class="line">        ListNode *slow = dummy;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast-&gt;next-&gt;val != fast-&gt;val)</span><br><span class="line">                <span class="comment">//更新slow</span></span><br><span class="line">                slow = fast;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//遍历重复的元素，fast落到重复元素的最后一个元素上。</span></span><br><span class="line">                <span class="keyword">while</span>(fast-&gt;next &amp;&amp; fast-&gt;next-&gt;val == fast-&gt;val)</span><br><span class="line">                    fast = fast-&gt;next;</span><br><span class="line">                <span class="comment">//删掉slow和fast之间的元素</span></span><br><span class="line">                slow-&gt;next = fast-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//更新fast</span></span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/tags/Leetcode/"/>
    
      <category term="List" scheme="https://wordzzzz.github.io/tags/List/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记（链表）：partition-list</title>
    <link href="https://wordzzzz.github.io/2018/01/16/LIST4/"/>
    <id>https://wordzzzz.github.io/2018/01/16/LIST4/</id>
    <published>2018-01-15T16:00:00.000Z</published>
    <updated>2018-01-16T12:55:12.428Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/LeetCode" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/LeetCode</a></strong></li><li><strong>刷题平台：<a href="https://www.nowcoder.com/ta/leetcode" target="_blank" rel="noopener">https://www.nowcoder.com/ta/leetcode</a></strong></li><li><strong>题&emsp;&emsp;库：Leetcode经典编程题</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><p>[toc]</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.</p><p>You should preserve the original relative order of the nodes in each of the two partitions.</p><p>For example,<br>Given1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2and x = 3,<br>return1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5.</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>牛客网上面的答案都是新建两个链表，小于x的放到一个链表里面，不小于的放到另一个链表里面，这种答案感觉好没劲哦。所以最后我采用的是O(n)时间复杂度，O(1)空间复杂度的解法。</p><p>具体说来，还是用快慢指针遍历链表，slow指向连续小于x的最后一个元素，fast指向当前元素不小于x但是下个元素小于x的元素。理解清楚这两个指针的对应关系之后，我们很容易将fast指向的元素的下一个元素追加到slow之后，同时更新slow和fast的指。</p><h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">partition</span><span class="params">(ListNode *head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        ListNode *fast = dummy;</span><br><span class="line">        ListNode *slow = dummy;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast-&gt;next-&gt;val &gt;= x)</span><br><span class="line">                fast = fast-&gt;next;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(fast == slow)&#123;</span><br><span class="line">                    fast = fast-&gt;next;</span><br><span class="line">                    slow = slow-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    ListNode *tmp = fast-&gt;next;</span><br><span class="line">                    fast-&gt;next = tmp-&gt;next;</span><br><span class="line">                    tmp-&gt;next = slow-&gt;next;</span><br><span class="line">                    slow-&gt;next = tmp;</span><br><span class="line">                    slow = slow-&gt;next;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/tags/Leetcode/"/>
    
      <category term="List" scheme="https://wordzzzz.github.io/tags/List/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记（链表）：reverse-linked-list-ii</title>
    <link href="https://wordzzzz.github.io/2018/01/16/LIST3/"/>
    <id>https://wordzzzz.github.io/2018/01/16/LIST3/</id>
    <published>2018-01-15T16:00:00.000Z</published>
    <updated>2018-01-16T12:54:01.580Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/LeetCode" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/LeetCode</a></strong></li><li><strong>刷题平台：<a href="https://www.nowcoder.com/ta/leetcode" target="_blank" rel="noopener">https://www.nowcoder.com/ta/leetcode</a></strong></li><li><strong>题&emsp;&emsp;库：Leetcode经典编程题</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><p>[toc]</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Reverse a linked list from position m to n. Do it in-place and in one-pass.</p><p>For example:<br>Given1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2 and n = 4,</p><p>return1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL.</p><p>Note:<br>Given m, n satisfy the following condition:<br>1 ≤ m ≤ n ≤ length of list.</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>可能是因为反转链表i太简单了，所以牛客网只有ii么，应该是这样的，哈哈哈。</p><p>头指针是必不可少的，因为有可能会要求全部反转。首先定位到需要反转的第一个元素，然后每次都将它后面的元素往它前面放。他们之间的关系大家最好自己画图捋一遍，这样记得比较清楚。</p><h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">reverseBetween</span><span class="params">(ListNode *head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> diff = n - m;</span><br><span class="line">        </span><br><span class="line">        ListNode *preHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        preHead-&gt;next = head;</span><br><span class="line">        ListNode *preCur = preHead;</span><br><span class="line">        ListNode *cur = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            preCur = cur;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; diff; ++i)&#123;</span><br><span class="line">            ListNode *tmp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = tmp-&gt;next;</span><br><span class="line">            tmp-&gt;next = preCur-&gt;next;</span><br><span class="line">            preCur-&gt;next = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> preHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/tags/Leetcode/"/>
    
      <category term="List" scheme="https://wordzzzz.github.io/tags/List/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记（链表）：convert-sorted-list-to-binary-search-tree</title>
    <link href="https://wordzzzz.github.io/2018/01/16/LIST2/"/>
    <id>https://wordzzzz.github.io/2018/01/16/LIST2/</id>
    <published>2018-01-15T16:00:00.000Z</published>
    <updated>2018-01-16T12:52:43.128Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/LeetCode" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/LeetCode</a></strong></li><li><strong>刷题平台：<a href="https://www.nowcoder.com/ta/leetcode" target="_blank" rel="noopener">https://www.nowcoder.com/ta/leetcode</a></strong></li><li><strong>题&emsp;&emsp;库：Leetcode经典编程题</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><p>[toc]</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>升序链表转换成高度平衡的二叉搜索树，我们只需要找到链表的中点当作root然后左右递归就可以了。求链表中点当然还是用快慢指针了。</p><h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode *<span class="title">sortedListToBST</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> toBST(head, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode *<span class="title">toBST</span><span class="params">(ListNode *head, ListNode *tail)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == tail)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *fast = head;</span><br><span class="line">        ListNode *slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != tail &amp;&amp; fast-&gt;next != tail)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> TreeNode(slow-&gt;val);</span><br><span class="line">        root-&gt;left = toBST(head, slow);</span><br><span class="line">        root-&gt;right = toBST(slow-&gt;next, tail);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/tags/Leetcode/"/>
    
      <category term="List" scheme="https://wordzzzz.github.io/tags/List/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记（链表）：copy-list-with-random-pointer</title>
    <link href="https://wordzzzz.github.io/2018/01/16/LIST1/"/>
    <id>https://wordzzzz.github.io/2018/01/16/LIST1/</id>
    <published>2018-01-15T16:00:00.000Z</published>
    <updated>2018-01-16T12:52:02.549Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/LeetCode" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/LeetCode</a></strong></li><li><strong>刷题平台：<a href="https://www.nowcoder.com/ta/leetcode" target="_blank" rel="noopener">https://www.nowcoder.com/ta/leetcode</a></strong></li><li><strong>题&emsp;&emsp;库：Leetcode经典编程题</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><p>[toc]</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.</p><p>Return a deep copy of the list.</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>我们可以将复杂链表的复制过程分解为三个步骤。在写代码的时候我们每一步定义一个函数，这样每个函数完成一个功能，整个过程的逻辑也就非常清晰明了了。</p><p>大部分人首先想到的可能是先复制复杂指针的label和next，然后再查找random并更新。查找random又分为两种，一种是每次都从头查找，时间复杂度为O(n^2)；另一种是空间换时间，复制label和next的同时建立一个hash表来存放新旧复杂指针的对应关系，所以后续只需一步就能找到random，算法时间复杂度为O(n)。</p><p>我们这里采用三步走战略，也是剑指offer上推崇的方法：</p><ul><li>第一步：复制复杂指针的label和next。但是这次我们把复制的结点跟在元结点后面，而不是直接创建新的链表；</li><li>第二步：设置复制出来的结点的random。因为新旧结点是前后对应关系，所以也是一步就能找到random；</li><li>第三步：拆分链表。奇数是原链表，偶数是复制的链表。</li></ul><p>有图思路更清晰：</p><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20171108132929521?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><br><p></p><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20171108132947451?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><br><p></p><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20171108133004592?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><br><p></p><p>这道题，我就不照搬之前的博客了，直接贴一种更简洁的代码。</p><h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list with a random pointer.</span></span><br><span class="line"><span class="comment"> * struct RandomListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int label;</span></span><br><span class="line"><span class="comment"> *     RandomListNode *next, *random;</span></span><br><span class="line"><span class="comment"> *     RandomListNode(int x) : label(x), next(NULL), random(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">RandomListNode *<span class="title">copyRandomList</span><span class="params">(RandomListNode *head)</span> </span>&#123;</span><br><span class="line">        RandomListNode *copy, *p;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//复制链表</span></span><br><span class="line">        <span class="keyword">for</span>(p = head; p; p = p-&gt;next)&#123;</span><br><span class="line">            copy = <span class="keyword">new</span> RandomListNode(p-&gt;label);</span><br><span class="line">            copy-&gt;next = p-&gt;next;</span><br><span class="line">            p = p-&gt;next = copy;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//复制random</span></span><br><span class="line">        <span class="keyword">for</span>(p = head; p; p = copy-&gt;next)&#123;</span><br><span class="line">            copy = p-&gt;next;</span><br><span class="line">            copy-&gt;random = (p-&gt;random ? p-&gt;random-&gt;next:<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//split链表</span></span><br><span class="line">        <span class="keyword">for</span>(p = head, head = copy = p-&gt;next; p;)&#123;</span><br><span class="line">            p = p-&gt;next = copy-&gt;next;</span><br><span class="line">            copy = copy-&gt;next = (p ? p-&gt;next:<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/tags/Leetcode/"/>
    
      <category term="List" scheme="https://wordzzzz.github.io/tags/List/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记（链表）：linked-list-cycle-ii</title>
    <link href="https://wordzzzz.github.io/2018/01/15/LIST4/"/>
    <id>https://wordzzzz.github.io/2018/01/15/LIST4/</id>
    <published>2018-01-14T16:00:00.000Z</published>
    <updated>2018-01-15T13:34:13.764Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/LeetCode" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/LeetCode</a></strong></li><li><strong>刷题平台：<a href="https://www.nowcoder.com/ta/leetcode" target="_blank" rel="noopener">https://www.nowcoder.com/ta/leetcode</a></strong></li><li><strong>题&emsp;&emsp;库：Leetcode经典编程题</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><p>[toc]</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a linked list, return the node where the cycle begins. If there is no cycle, returnnull.</p><p>Follow up:<br>Can you solve it without using extra space?</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li>同linked-list-cycle-i一题，使用快慢指针方法，判定是否存在环，并记录两指针相遇位置(Z)；</li><li>有环的情况下， 求链表的入环节点：遍历链表，把每个元素指向下个链表的指针赋值为NULL，则循环要么在链表结尾停止，要么在环状链表入口处停止。</li></ul><h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//判断是否为环状链表</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ListNode *fast = head;</span><br><span class="line">        ListNode *slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast-&gt;next != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(slow-&gt;val == fast-&gt;val)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//检测函数</span></span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hasCycle(head)) &#123;</span><br><span class="line">            ListNode *temp = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">while</span>(head -&gt;next) &#123;</span><br><span class="line">                temp = head -&gt;next;</span><br><span class="line">                head -&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">                head = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://wordzzzz.github.io/tags/Leetcode/"/>
    
      <category term="List" scheme="https://wordzzzz.github.io/tags/List/"/>
    
  </entry>
  
</feed>
