<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WordZzzz</title>
  
  <subtitle>My Awesome Site</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wordzzzz.gitee.io/"/>
  <updated>2018-01-17T03:10:34.492Z</updated>
  <id>http://wordzzzz.gitee.io/</id>
  
  <author>
    <name>Word Zzzz</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode刷题笔记（链表）：merge-two-sorted-lists</title>
    <link href="http://wordzzzz.gitee.io/2018/01/17/LIST3/"/>
    <id>http://wordzzzz.gitee.io/2018/01/17/LIST3/</id>
    <published>2018-01-16T16:00:00.000Z</published>
    <updated>2018-01-17T03:10:34.492Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/LeetCode" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/LeetCode</a></strong></li><li><strong>刷题平台：<a href="https://www.nowcoder.com/ta/leetcode" target="_blank" rel="noopener">https://www.nowcoder.com/ta/leetcode</a></strong></li><li><strong>题&emsp;&emsp;库：Leetcode经典编程题</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><p>[toc]</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这道题剑指offer上应该也是有的，我就不去翻了。既然已经排序了，事情就变得简单多了，自下而上的归并排序的最后一步嘛~我们还是申请个新的结点，然后直接遍历两个链表元素比大小就好。</p><p>需要注意的是循环的终止条件，循环结束后还要把剩下的链表追加到cur的屁股后面哦。</p><h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">mergeTwoLists</span><span class="params">(ListNode *l1, ListNode *l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(l2 == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        </span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode *cur = dummy;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">NULL</span> &amp;&amp; l2 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)&#123;</span><br><span class="line">                cur-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cur-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = l1 ? l1 : l2;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="Leetcode" scheme="http://wordzzzz.gitee.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://wordzzzz.gitee.io/tags/Leetcode/"/>
    
      <category term="List" scheme="http://wordzzzz.gitee.io/tags/List/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记（链表）：remove-duplicates-from-sorted-list-ii</title>
    <link href="http://wordzzzz.gitee.io/2018/01/17/LIST2/"/>
    <id>http://wordzzzz.gitee.io/2018/01/17/LIST2/</id>
    <published>2018-01-16T16:00:00.000Z</published>
    <updated>2018-01-17T03:10:06.059Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/LeetCode" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/LeetCode</a></strong></li><li><strong>刷题平台：<a href="https://www.nowcoder.com/ta/leetcode" target="_blank" rel="noopener">https://www.nowcoder.com/ta/leetcode</a></strong></li><li><strong>题&emsp;&emsp;库：Leetcode经典编程题</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><p>[toc]</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.</p><p>For example,<br>Given1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5, return1-&gt;2-&gt;5.<br>Given1-&gt;1-&gt;1-&gt;2-&gt;3, return2-&gt;3.</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>因为第一个元素就有可能是重复节点，所以我们需要新建一个头节点指针，这一点在之前的几道题都有提到过。然后设置快慢指针，fast从head开始遍历，slow总是比fast慢一步；如果fast当前元素和它的下一个元素不相等，则更新slow、fast；否则，遍历重复元素，直到fast落到最后一个重复元素上，然后更新slow（跳过重复节点，直接指向fast的下一个节点）、fast。</p><h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">deleteDuplicates</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        ListNode *fast = head;</span><br><span class="line">        ListNode *slow = dummy;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast-&gt;next-&gt;val != fast-&gt;val)</span><br><span class="line">                <span class="comment">//更新slow</span></span><br><span class="line">                slow = fast;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//遍历重复的元素，fast落到重复元素的最后一个元素上。</span></span><br><span class="line">                <span class="keyword">while</span>(fast-&gt;next &amp;&amp; fast-&gt;next-&gt;val == fast-&gt;val)</span><br><span class="line">                    fast = fast-&gt;next;</span><br><span class="line">                <span class="comment">//删掉slow和fast之间的元素</span></span><br><span class="line">                slow-&gt;next = fast-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//更新fast</span></span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="Leetcode" scheme="http://wordzzzz.gitee.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://wordzzzz.gitee.io/tags/Leetcode/"/>
    
      <category term="List" scheme="http://wordzzzz.gitee.io/tags/List/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记（链表）：remove-duplicates-from-sorted-list</title>
    <link href="http://wordzzzz.gitee.io/2018/01/17/LIST1/"/>
    <id>http://wordzzzz.gitee.io/2018/01/17/LIST1/</id>
    <published>2018-01-16T16:00:00.000Z</published>
    <updated>2018-01-17T03:09:34.419Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/LeetCode" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/LeetCode</a></strong></li><li><strong>刷题平台：<a href="https://www.nowcoder.com/ta/leetcode" target="_blank" rel="noopener">https://www.nowcoder.com/ta/leetcode</a></strong></li><li><strong>题&emsp;&emsp;库：Leetcode经典编程题</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><p>[toc]</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a sorted linked list, delete all duplicates such that each element appear only once.</p><p>For example,<br>Given1-&gt;1-&gt;2, return1-&gt;2.<br>Given1-&gt;1-&gt;2-&gt;3-&gt;3, return1-&gt;2-&gt;3.</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>简单问题不要想的太复杂，直接嵌套循环搞定喽。外循环用来遍历链表，内循环用来遍历重复元素，如果重复就一直传递指针。</p><h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">deleteDuplicates</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *dummy = head;</span><br><span class="line">        <span class="keyword">while</span>(dummy != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(dummy-&gt;next != <span class="literal">NULL</span> &amp;&amp; dummy-&gt;val == dummy-&gt;next-&gt;val)&#123;</span><br><span class="line">                dummy-&gt;next = dummy-&gt;next-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            dummy = dummy-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="Leetcode" scheme="http://wordzzzz.gitee.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://wordzzzz.gitee.io/tags/Leetcode/"/>
    
      <category term="List" scheme="http://wordzzzz.gitee.io/tags/List/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记（链表）：rotate-list</title>
    <link href="http://wordzzzz.gitee.io/2018/01/17/LIST4/"/>
    <id>http://wordzzzz.gitee.io/2018/01/17/LIST4/</id>
    <published>2018-01-16T16:00:00.000Z</published>
    <updated>2018-01-17T03:11:04.806Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/LeetCode" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/LeetCode</a></strong></li><li><strong>刷题平台：<a href="https://www.nowcoder.com/ta/leetcode" target="_blank" rel="noopener">https://www.nowcoder.com/ta/leetcode</a></strong></li><li><strong>题&emsp;&emsp;库：Leetcode经典编程题</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><p>[toc]</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a list, rotate the list to the right by k places, where k is non-negative.</p><p>For example:<br>Given1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULLand k =2,<br>return4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL.</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li>遍历链表得到链表长度并定位fast到尾结点；</li><li>根据链表长度，slow找到新的尾结点，slow的下一个结点便是新的头结点因为k可能比len大，所以需要取余数；</li><li>原先的尾结点与原先的头节点相连，dummy的next指针更新指向新的头结点，同时断开新的尾节点与新的头结点之间的联系。</li></ul><h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">rotateRight</span><span class="params">(ListNode *head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span> || head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        ListNode *fast = head;</span><br><span class="line">        ListNode *slow = head;</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="comment">//计算链表长度，同时fast指向尾结点</span></span><br><span class="line">        <span class="keyword">for</span>(len = <span class="number">1</span>; fast-&gt;next != <span class="literal">NULL</span>; ++len)</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        <span class="comment">//根据得到的链表长度，找到需要切开的结点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len - k % len; ++i)</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        fast-&gt;next = dummy-&gt;next;   <span class="comment">//尾结点连接到头节点，形成环状链表</span></span><br><span class="line">        dummy-&gt;next = slow-&gt;next;   <span class="comment">//fast的下一个结点作为新的头结点</span></span><br><span class="line">        slow-&gt;next = <span class="literal">NULL</span>;          <span class="comment">//slow结点和新的头结点断开</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="Leetcode" scheme="http://wordzzzz.gitee.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://wordzzzz.gitee.io/tags/Leetcode/"/>
    
      <category term="List" scheme="http://wordzzzz.gitee.io/tags/List/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记（链表）：partition-list</title>
    <link href="http://wordzzzz.gitee.io/2018/01/16/LIST4/"/>
    <id>http://wordzzzz.gitee.io/2018/01/16/LIST4/</id>
    <published>2018-01-15T16:00:00.000Z</published>
    <updated>2018-01-16T12:55:12.428Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/LeetCode" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/LeetCode</a></strong></li><li><strong>刷题平台：<a href="https://www.nowcoder.com/ta/leetcode" target="_blank" rel="noopener">https://www.nowcoder.com/ta/leetcode</a></strong></li><li><strong>题&emsp;&emsp;库：Leetcode经典编程题</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><p>[toc]</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.</p><p>You should preserve the original relative order of the nodes in each of the two partitions.</p><p>For example,<br>Given1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2and x = 3,<br>return1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5.</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>牛客网上面的答案都是新建两个链表，小于x的放到一个链表里面，不小于的放到另一个链表里面，这种答案感觉好没劲哦。所以最后我采用的是O(n)时间复杂度，O(1)空间复杂度的解法。</p><p>具体说来，还是用快慢指针遍历链表，slow指向连续小于x的最后一个元素，fast指向当前元素不小于x但是下个元素小于x的元素。理解清楚这两个指针的对应关系之后，我们很容易将fast指向的元素的下一个元素追加到slow之后，同时更新slow和fast的指。</p><h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">partition</span><span class="params">(ListNode *head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        ListNode *fast = dummy;</span><br><span class="line">        ListNode *slow = dummy;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast-&gt;next-&gt;val &gt;= x)</span><br><span class="line">                fast = fast-&gt;next;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(fast == slow)&#123;</span><br><span class="line">                    fast = fast-&gt;next;</span><br><span class="line">                    slow = slow-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    ListNode *tmp = fast-&gt;next;</span><br><span class="line">                    fast-&gt;next = tmp-&gt;next;</span><br><span class="line">                    tmp-&gt;next = slow-&gt;next;</span><br><span class="line">                    slow-&gt;next = tmp;</span><br><span class="line">                    slow = slow-&gt;next;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="Leetcode" scheme="http://wordzzzz.gitee.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://wordzzzz.gitee.io/tags/Leetcode/"/>
    
      <category term="List" scheme="http://wordzzzz.gitee.io/tags/List/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记（链表）：convert-sorted-list-to-binary-search-tree</title>
    <link href="http://wordzzzz.gitee.io/2018/01/16/LIST2/"/>
    <id>http://wordzzzz.gitee.io/2018/01/16/LIST2/</id>
    <published>2018-01-15T16:00:00.000Z</published>
    <updated>2018-01-16T12:52:43.128Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/LeetCode" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/LeetCode</a></strong></li><li><strong>刷题平台：<a href="https://www.nowcoder.com/ta/leetcode" target="_blank" rel="noopener">https://www.nowcoder.com/ta/leetcode</a></strong></li><li><strong>题&emsp;&emsp;库：Leetcode经典编程题</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><p>[toc]</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>升序链表转换成高度平衡的二叉搜索树，我们只需要找到链表的中点当作root然后左右递归就可以了。求链表中点当然还是用快慢指针了。</p><h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode *<span class="title">sortedListToBST</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> toBST(head, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode *<span class="title">toBST</span><span class="params">(ListNode *head, ListNode *tail)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == tail)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *fast = head;</span><br><span class="line">        ListNode *slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != tail &amp;&amp; fast-&gt;next != tail)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> TreeNode(slow-&gt;val);</span><br><span class="line">        root-&gt;left = toBST(head, slow);</span><br><span class="line">        root-&gt;right = toBST(slow-&gt;next, tail);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="Leetcode" scheme="http://wordzzzz.gitee.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://wordzzzz.gitee.io/tags/Leetcode/"/>
    
      <category term="List" scheme="http://wordzzzz.gitee.io/tags/List/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记（链表）：reverse-linked-list-ii</title>
    <link href="http://wordzzzz.gitee.io/2018/01/16/LIST3/"/>
    <id>http://wordzzzz.gitee.io/2018/01/16/LIST3/</id>
    <published>2018-01-15T16:00:00.000Z</published>
    <updated>2018-01-16T12:54:01.580Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/LeetCode" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/LeetCode</a></strong></li><li><strong>刷题平台：<a href="https://www.nowcoder.com/ta/leetcode" target="_blank" rel="noopener">https://www.nowcoder.com/ta/leetcode</a></strong></li><li><strong>题&emsp;&emsp;库：Leetcode经典编程题</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><p>[toc]</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Reverse a linked list from position m to n. Do it in-place and in one-pass.</p><p>For example:<br>Given1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2 and n = 4,</p><p>return1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL.</p><p>Note:<br>Given m, n satisfy the following condition:<br>1 ≤ m ≤ n ≤ length of list.</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>可能是因为反转链表i太简单了，所以牛客网只有ii么，应该是这样的，哈哈哈。</p><p>头指针是必不可少的，因为有可能会要求全部反转。首先定位到需要反转的第一个元素，然后每次都将它后面的元素往它前面放。他们之间的关系大家最好自己画图捋一遍，这样记得比较清楚。</p><h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">reverseBetween</span><span class="params">(ListNode *head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> diff = n - m;</span><br><span class="line">        </span><br><span class="line">        ListNode *preHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        preHead-&gt;next = head;</span><br><span class="line">        ListNode *preCur = preHead;</span><br><span class="line">        ListNode *cur = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            preCur = cur;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; diff; ++i)&#123;</span><br><span class="line">            ListNode *tmp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = tmp-&gt;next;</span><br><span class="line">            tmp-&gt;next = preCur-&gt;next;</span><br><span class="line">            preCur-&gt;next = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> preHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="Leetcode" scheme="http://wordzzzz.gitee.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://wordzzzz.gitee.io/tags/Leetcode/"/>
    
      <category term="List" scheme="http://wordzzzz.gitee.io/tags/List/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记（链表）：copy-list-with-random-pointer</title>
    <link href="http://wordzzzz.gitee.io/2018/01/16/LIST1/"/>
    <id>http://wordzzzz.gitee.io/2018/01/16/LIST1/</id>
    <published>2018-01-15T16:00:00.000Z</published>
    <updated>2018-01-16T12:52:02.549Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/LeetCode" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/LeetCode</a></strong></li><li><strong>刷题平台：<a href="https://www.nowcoder.com/ta/leetcode" target="_blank" rel="noopener">https://www.nowcoder.com/ta/leetcode</a></strong></li><li><strong>题&emsp;&emsp;库：Leetcode经典编程题</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><p>[toc]</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.</p><p>Return a deep copy of the list.</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>我们可以将复杂链表的复制过程分解为三个步骤。在写代码的时候我们每一步定义一个函数，这样每个函数完成一个功能，整个过程的逻辑也就非常清晰明了了。</p><p>大部分人首先想到的可能是先复制复杂指针的label和next，然后再查找random并更新。查找random又分为两种，一种是每次都从头查找，时间复杂度为O(n^2)；另一种是空间换时间，复制label和next的同时建立一个hash表来存放新旧复杂指针的对应关系，所以后续只需一步就能找到random，算法时间复杂度为O(n)。</p><p>我们这里采用三步走战略，也是剑指offer上推崇的方法：</p><ul><li>第一步：复制复杂指针的label和next。但是这次我们把复制的结点跟在元结点后面，而不是直接创建新的链表；</li><li>第二步：设置复制出来的结点的random。因为新旧结点是前后对应关系，所以也是一步就能找到random；</li><li>第三步：拆分链表。奇数是原链表，偶数是复制的链表。</li></ul><p>有图思路更清晰：</p><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20171108132929521?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><br><p></p><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20171108132947451?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><br><p></p><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20171108133004592?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><br><p></p><p>这道题，我就不照搬之前的博客了，直接贴一种更简洁的代码。</p><h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list with a random pointer.</span></span><br><span class="line"><span class="comment"> * struct RandomListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int label;</span></span><br><span class="line"><span class="comment"> *     RandomListNode *next, *random;</span></span><br><span class="line"><span class="comment"> *     RandomListNode(int x) : label(x), next(NULL), random(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">RandomListNode *<span class="title">copyRandomList</span><span class="params">(RandomListNode *head)</span> </span>&#123;</span><br><span class="line">        RandomListNode *copy, *p;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//复制链表</span></span><br><span class="line">        <span class="keyword">for</span>(p = head; p; p = p-&gt;next)&#123;</span><br><span class="line">            copy = <span class="keyword">new</span> RandomListNode(p-&gt;label);</span><br><span class="line">            copy-&gt;next = p-&gt;next;</span><br><span class="line">            p = p-&gt;next = copy;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//复制random</span></span><br><span class="line">        <span class="keyword">for</span>(p = head; p; p = copy-&gt;next)&#123;</span><br><span class="line">            copy = p-&gt;next;</span><br><span class="line">            copy-&gt;random = (p-&gt;random ? p-&gt;random-&gt;next:<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//split链表</span></span><br><span class="line">        <span class="keyword">for</span>(p = head, head = copy = p-&gt;next; p;)&#123;</span><br><span class="line">            p = p-&gt;next = copy-&gt;next;</span><br><span class="line">            copy = copy-&gt;next = (p ? p-&gt;next:<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="Leetcode" scheme="http://wordzzzz.gitee.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://wordzzzz.gitee.io/tags/Leetcode/"/>
    
      <category term="List" scheme="http://wordzzzz.gitee.io/tags/List/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记（链表）：reorder-list</title>
    <link href="http://wordzzzz.gitee.io/2018/01/15/LIST2/"/>
    <id>http://wordzzzz.gitee.io/2018/01/15/LIST2/</id>
    <published>2018-01-14T16:00:00.000Z</published>
    <updated>2018-01-15T13:32:45.399Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/LeetCode" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/LeetCode</a></strong></li><li><strong>刷题平台：<a href="https://www.nowcoder.com/ta/leetcode" target="_blank" rel="noopener">https://www.nowcoder.com/ta/leetcode</a></strong></li><li><strong>题&emsp;&emsp;库：Leetcode经典编程题</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><p>[toc]</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a singly linked list L: L 0→L 1→…→L n-1→L n,<br>reorder it to: L 0→L n →L 1→L n-1→L 2→L n-2→…</p><p>You must do this in-place without altering the nodes’ values.</p><p>For example,<br>Given{1,2,3,4}, reorder it to{1,4,2,3}.</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>要求in-place，所以不能使用辅助空间。可以采用快慢指针先找到中间点，将原列表分成两个部分，然后再将后半部分反转链表，最后再根据题目规则一前一后合并成一个链表。</p><h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode *<span class="title">getMiddle</span><span class="params">(ListNode *head)</span></span>&#123;</span><br><span class="line">        ListNode *fast = head;</span><br><span class="line">        ListNode *slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast-&gt;next != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode *<span class="title">reverseList</span><span class="params">(ListNode *head)</span></span>&#123;</span><br><span class="line">        ListNode *pReversedHead = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *pNode = head;</span><br><span class="line">        ListNode *pPrev = <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(pNode != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            ListNode *pNext = pNode-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(pNext == <span class="literal">NULL</span>)</span><br><span class="line">                pReversedHead = pNode;</span><br><span class="line">            pNode-&gt;next = pPrev;</span><br><span class="line">            pPrev = pNode;</span><br><span class="line">            pNode = pNext;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pReversedHead;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mergeList</span><span class="params">(ListNode *left, ListNode *right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left != <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            ListNode *curLeft = left-&gt;next;</span><br><span class="line">            ListNode *curRight = right-&gt;next;</span><br><span class="line">            left-&gt;next = right;</span><br><span class="line">            right-&gt;next = curLeft;</span><br><span class="line">            left = curLeft;</span><br><span class="line">            right = curRight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        </span><br><span class="line">        ListNode *middle = getMiddle(head);</span><br><span class="line">        ListNode *right = reverseList(middle-&gt;next);</span><br><span class="line">        middle-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *left = head;</span><br><span class="line">        mergeList(left, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="Leetcode" scheme="http://wordzzzz.gitee.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://wordzzzz.gitee.io/tags/Leetcode/"/>
    
      <category term="List" scheme="http://wordzzzz.gitee.io/tags/List/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记（链表）：linked-list-cycle-ii</title>
    <link href="http://wordzzzz.gitee.io/2018/01/15/LIST4/"/>
    <id>http://wordzzzz.gitee.io/2018/01/15/LIST4/</id>
    <published>2018-01-14T16:00:00.000Z</published>
    <updated>2018-01-15T13:34:13.764Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/LeetCode" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/LeetCode</a></strong></li><li><strong>刷题平台：<a href="https://www.nowcoder.com/ta/leetcode" target="_blank" rel="noopener">https://www.nowcoder.com/ta/leetcode</a></strong></li><li><strong>题&emsp;&emsp;库：Leetcode经典编程题</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><p>[toc]</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a linked list, return the node where the cycle begins. If there is no cycle, returnnull.</p><p>Follow up:<br>Can you solve it without using extra space?</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li>同linked-list-cycle-i一题，使用快慢指针方法，判定是否存在环，并记录两指针相遇位置(Z)；</li><li>有环的情况下， 求链表的入环节点：遍历链表，把每个元素指向下个链表的指针赋值为NULL，则循环要么在链表结尾停止，要么在环状链表入口处停止。</li></ul><h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//判断是否为环状链表</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ListNode *fast = head;</span><br><span class="line">        ListNode *slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast-&gt;next != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(slow-&gt;val == fast-&gt;val)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//检测函数</span></span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hasCycle(head)) &#123;</span><br><span class="line">            ListNode *temp = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">while</span>(head -&gt;next) &#123;</span><br><span class="line">                temp = head -&gt;next;</span><br><span class="line">                head -&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">                head = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="Leetcode" scheme="http://wordzzzz.gitee.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://wordzzzz.gitee.io/tags/Leetcode/"/>
    
      <category term="List" scheme="http://wordzzzz.gitee.io/tags/List/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记（链表）：linked-list-cycle</title>
    <link href="http://wordzzzz.gitee.io/2018/01/15/LIST3/"/>
    <id>http://wordzzzz.gitee.io/2018/01/15/LIST3/</id>
    <published>2018-01-14T16:00:00.000Z</published>
    <updated>2018-01-15T13:33:39.033Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/LeetCode" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/LeetCode</a></strong></li><li><strong>刷题平台：<a href="https://www.nowcoder.com/ta/leetcode" target="_blank" rel="noopener">https://www.nowcoder.com/ta/leetcode</a></strong></li><li><strong>题&emsp;&emsp;库：Leetcode经典编程题</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><p>[toc]</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a linked list, determine if it has a cycle in it.</p><p>Follow up:<br>Can you solve it without using extra space?</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>又双叒叕是快慢指针，话不多说，上代码。</p><h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ListNode *fast = head;</span><br><span class="line">        ListNode *slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast-&gt;next != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(slow-&gt;val == fast-&gt;val)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="Leetcode" scheme="http://wordzzzz.gitee.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://wordzzzz.gitee.io/tags/Leetcode/"/>
    
      <category term="List" scheme="http://wordzzzz.gitee.io/tags/List/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记（链表）：sort-list</title>
    <link href="http://wordzzzz.gitee.io/2018/01/15/LIST1/"/>
    <id>http://wordzzzz.gitee.io/2018/01/15/LIST1/</id>
    <published>2018-01-14T16:00:00.000Z</published>
    <updated>2018-01-15T13:32:09.025Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/LeetCode" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/LeetCode</a></strong></li><li><strong>刷题平台：<a href="https://www.nowcoder.com/ta/leetcode" target="_blank" rel="noopener">https://www.nowcoder.com/ta/leetcode</a></strong></li><li><strong>题&emsp;&emsp;库：Leetcode经典编程题</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><p>[toc]</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Sort a linked list in O(n log n) time using constant space complexity.</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>因为题目要求复杂度为O(nlogn),故可以考虑归并排序的思想。</p><p>前一段时间刚刚总结了八大排序，感兴趣的同学们可以由此穿越：<a href="https://wordzzzz.github.io/2018/01/07/DS/" target="_blank" rel="noopener">数据结构与算法系列之一：八大排序之归并排序</a>。</p><p>递归版归并排序的一般步骤为：</p><ul><li>将待排序数组（链表）取中点并一分为二；</li><li>递归地对左半部分进行归并排序；</li><li>递归地对右半部分进行归并排序；</li><li>将两个半部分进行合并（merge）,得到结果。</li></ul><p>所以对应此题目，可以划分为三个小问题：</p><ul><li>找到链表中点 （快慢指针思路，快指针一次走两步，慢指针一次走一步，快指针在链表末尾时，慢指针恰好在链表中点）；</li><li>写出merge函数，即如何合并链表。 </li><li>写出mergesort函数，实现上述步骤。</li></ul><h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//快慢指针获取链表中点</span></span><br><span class="line">    <span class="function">ListNode *<span class="title">getMiddle</span><span class="params">(ListNode *head)</span></span>&#123;</span><br><span class="line">        ListNode *fast = head;</span><br><span class="line">        ListNode *slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast-&gt;next != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//合并链表</span></span><br><span class="line">    <span class="function">ListNode *<span class="title">mergeList</span><span class="params">(ListNode *left, ListNode *right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">if</span>(right == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        </span><br><span class="line">        ListNode *tmp = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode *head = tmp;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left != <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(left-&gt;val &gt; right-&gt;val)&#123;</span><br><span class="line">                head-&gt;next = right;</span><br><span class="line">                right = right-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                head-&gt;next = left;</span><br><span class="line">                left = left-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">NULL</span>)</span><br><span class="line">            head-&gt;next = right;</span><br><span class="line">        <span class="keyword">if</span>(right == <span class="literal">NULL</span>)</span><br><span class="line">            head-&gt;next = left;</span><br><span class="line">        <span class="keyword">return</span> tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//排序函数</span></span><br><span class="line">    <span class="function">ListNode *<span class="title">sortList</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        ListNode *middle = getMiddle(head);</span><br><span class="line">        ListNode *right = sortList(middle-&gt;next);</span><br><span class="line">        middle-&gt;next = <span class="literal">NULL</span>;        <span class="comment">//左链表的结尾不能再指向右链表的开头</span></span><br><span class="line">        ListNode *left = sortList(head);</span><br><span class="line">        <span class="keyword">return</span> mergeList(left, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="Leetcode" scheme="http://wordzzzz.gitee.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://wordzzzz.gitee.io/tags/Leetcode/"/>
    
      <category term="List" scheme="http://wordzzzz.gitee.io/tags/List/"/>
    
  </entry>
  
  <entry>
    <title>我的个人博客之旅：从jekyll到hexo</title>
    <link href="http://wordzzzz.gitee.io/2018/01/10/HEXO/"/>
    <id>http://wordzzzz.gitee.io/2018/01/10/HEXO/</id>
    <published>2018-01-09T16:00:00.000Z</published>
    <updated>2018-01-10T07:00:18.229Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><p>[toc]</p><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;喜欢写Blog的人，会经历三个阶段。</p><ul><li>第一阶段，刚接触Blog，觉得很新鲜，试着选择一个免费空间来写。</li><li>第二阶段，发现免费空间限制太多，就自己购买域名和空间，搭建独立博客。</li><li>第三阶段，觉得独立博客的管理太麻烦，最好在保留控制权的前提下，让别人来管，自己只负责写文章。</li></ul><p>引自<a href="http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html" target="_blank" rel="noopener">阮一峰</a></p><p>&emsp;&emsp;第一阶段我已经经历过了，目前在CSDN的文章仍然在更新。但是作为一个免费空间，一个技术博客的聚集地，其管理和运营虽说正在变得越来越好，但是恶心人的事件也时有发生，比如对新手不友好的审核机制、近期改版造成的各种不兼容问题。</p><p>&emsp;&emsp;于是，就想着挣脱枷锁，向第二第三阶段发展。</p><p>&emsp;&emsp;我这人吧凡事都考虑的比较详尽，，我感觉我如果再去经历第二阶段的话既浪费精力又消耗时间，而且自己也过了玩网站、玩博客的年纪，如果申请个域名再搞个网站，我不知道这股热度会持续多久。</p><p>&emsp;&emsp;所以，我就直接跳到了第三个阶段，开始在github上搭建自己的博客。由于自己对前端一无所知，即使使用现成的博客框架，刚开始玩的时候特别费劲。但是经过不断摸索，我的博客已经基本成型，传送门开启：<a href="https://wordzzzz.github.io/" target="_blank" rel="noopener">wordzzzz的个人博客-托管于github</a> <a href="https://wordzzzz.gitee.io/">wordzzzz的个人博客-托管于gitee</a>。</p><p>&emsp;&emsp;本篇博文并不打算长篇大论的介绍基于GitHub Pages或者Gitee Pages搭建博客的步骤，因为这类的文章实在是太多了，青菜萝卜又各有所爱，不如给出资源，让大家自己折腾。所以我只是在此有序贴出我在搭建博客的过程中用到的各种有用资源，以及搭建博客的大致流程，也算是对我这段时间的一个告别仪式吧。</p><h2 id="GitHub-Pages"><a href="#GitHub-Pages" class="headerlink" title="GitHub Pages"></a>GitHub Pages</h2><p>&emsp;&emsp;我想在GitHub Pages推出之前，由于技术门槛的存在，第三个阶段应该会很少有人涉足。所以在开始一切之前，我们先来看看什么是<a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a>。</p><p>&emsp;&emsp;Github Pages 是面向用户、组织和项目开放的公共静态页面搭建托管服 务，站点可以被免费托管在 Github 上，你可以选择使用 Github Pages 默 认提供的域名 github.io 或者自定义域名来发布站点。Github Pages 支持 自动利用 Jekyll 生成站点，也同样支持纯 HTML 文档，将你的 Jekyll 站 点托管在 Github Pages 上是一个不错的选择。</p><p>&emsp;&emsp;网站首页就是搭建GitHub Pages的过程其中第一步之后，选择不同的git客户端选项，会出现相应的初始化步骤，很人性化。</p><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20180110111003603?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><br><p></p><p>&emsp;&emsp;大家可以跟着上面的链接先在自己的github新建仓库，仓库名称为username.github.io，其中username要替换成你github的名称，比如我的github名称为wordzzzz，所以我新建的仓库就应该是wordzzzz.github.io。那么等我以后搭建好了我的博客，我就可以通过<a href="https://wordzzzz.github.io来访问我的主页了。" target="_blank" rel="noopener">https://wordzzzz.github.io来访问我的主页了。</a></p><p>&emsp;&emsp;到现在为止，只是搭建博客的准备工作。搭建博客的下一步是选择合适的静态博客框架。</p><h2 id="jekyll-or-hexo"><a href="#jekyll-or-hexo" class="headerlink" title="jekyll or hexo"></a>jekyll or hexo</h2><p>&emsp;&emsp;目前有两大静态博客主流框架：<a href="http://jekyllcn.com/" target="_blank" rel="noopener">jekyll</a>和<a href="https://hexo.io/" target="_blank" rel="noopener">hexo</a>。</p><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20180110111311091?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><br><p></p><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20180110111420247?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><br><p></p><p>&emsp;&emsp;我一开始用的是jekyll，这是中文社区翻译出来的<a href="http://jekyllcn.com/" target="_blank" rel="noopener">中文开发文档</a>。我使用的主题是<a href="https://mmistakes.github.io/minimal-mistakes/" target="_blank" rel="noopener">Minimal Mistakes</a>，开发文档很详细。但是后来由于jekyll体验不是很好（中文资料少，我英语比较差我会说嘛），依赖环境总是出问题（需要安装ruby），markdown采用的是Kramdown（Kramdown对我之前的一些博客格式支持的不是很好，我自己写文档用的都是小书匠，然后发表到CSDN，所以并不想花时间在改格式上面），而且我使用的这个主题是个人维护的，种种原因导致最后做出来的博客很难符合我的胃口，最后被我扔进了停尸房<a href="https://github.com/WordZzzz/jekyll_mysite" target="_blank" rel="noopener">jekyll_mysite</a>。</p><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20180110111512090?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><br><p></p><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20180110111533728?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><br><p></p><p>&emsp;&emsp;就在我将要放弃之时，hexo拯救了我。对，没错，它有<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">中文开发文档</a>。而在hexo界，使用最多的主题就是<a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">next</a>了。光是看到这两份资料，我就已经激动的不行了，这种扁平化设计的网站，不就正是我需要的么。加上详尽的开发文档和丰富的第三方接口，让我对它爱不释手。最终定稿了自己的个人博客，存储在github<a href="https://wordzzzz.github.io/" target="_blank" rel="noopener">wordzzzz的个人博客-托管于github</a>和gitee<a href="https://wordzzzz.gitee.io/">wordzzzz的个人博客-托管于gitee</a>上。</p><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20180110142732584?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><br><p></p><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20180110142739639?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><br><p></p><h2 id="next主题"><a href="#next主题" class="headerlink" title="next主题"></a>next主题</h2><p>&emsp;&emsp;next主题支持三种外观显示，支持多国语言，5套代码高亮主题，可以深度定制。在其<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">Github</a>上，更是有三个主题的代表作，其中我最喜欢的莫过于基于Muse scheme的<a href="https://notes.wanghao.work/" target="_blank" rel="noopener">wanghao的博客</a>。于是，我就在wanghao的博客的基础上进行了相应的更改，形成了我现在的博客，主题文件全部在我的<a href="https://github.com/WordZzzz/hexo-next" target="_blank" rel="noopener">github</a>上，欢迎大家fork、star、follow。</p><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20180110114341558?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><br><p></p><p>&emsp;&emsp;其实先按照hexo配置开发环境，再按照next文档配置站点文件，完全可以轻松搭建起自己的博客。但是还是藏不住内心那颗年轻的心啊，终究还是搜罗了一些好玩的东西放到了自己的博客上，比如音乐播放器。</p><p>&emsp;&emsp;下面我先简单介绍一下基于github平台、hexo框架的next主题博客开发步骤：</p><ul><li><a href="">Github上新建username.github.io仓库并初始化</a></li><li><a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">PC端安装hexo及其依赖项并熟悉开发流程</a></li><li><a href="https://github.com/WordZzzz/hexo-next" target="_blank" rel="noopener">下载我的主题文件</a>或者<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">下载next主题文件</a></li><li><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">按照next官方教程验证主题</a></li><li><a href="http://theme-next.iissnan.com/theme-settings.html" target="_blank" rel="noopener">按照next官方教程配置站点文件和主题文件</a></li><li><a href="http://theme-next.iissnan.com/third-party-services.html" target="_blank" rel="noopener">按照next官方教程集成第三方服务</a></li><li><a href="https://hexo.io/zh-cn/docs/generating.html" target="_blank" rel="noopener">生成静态文件</a></li><li><a href="https://hexo.io/zh-cn/docs/server.html" target="_blank" rel="noopener">开启本地服务查看站点效果</a></li><li><a href="https://hexo.io/zh-cn/docs/deployment.html" target="_blank" rel="noopener">部署至Github</a></li></ul><p>&emsp;&emsp;文档都非常详细，下面我主要就第三方服务做一些说明。我提到的大部分三方服务在<a href="http://theme-next.iissnan.com/third-party-services.html" target="_blank" rel="noopener">next的官方文档</a>都提及到了，所以具体配置大家跟着官方文档走就行，我只是为每一类服务选择哪个做一下建议。</p><h3 id="评论系统"><a href="#评论系统" class="headerlink" title="评论系统"></a>评论系统</h3><p>&emsp;&emsp;我用的韩国的<a href="https://livere.com/" target="_blank" rel="noopener">livere</a>，从国内到国外，支持几乎全部社交账号登陆，具体步骤请按照<a href="http://theme-next.iissnan.com/third-party-services.html" target="_blank" rel="noopener">next的官方文档</a>操作。</p><h3 id="数据统计与分析"><a href="#数据统计与分析" class="headerlink" title="数据统计与分析"></a>数据统计与分析</h3><p>&emsp;&emsp;<a href="https://tongji.baidu.com/web/welcome/login" target="_blank" rel="noopener">百度统计</a>和<a href="https://www.google.com/intl/zh-CN/analytics/" target="_blank" rel="noopener">google分析</a>我都加上了，具体步骤请按照<a href="http://theme-next.iissnan.com/third-party-services.html" target="_blank" rel="noopener">next的官方文档</a>操作。</p><h3 id="阅读量统计"><a href="#阅读量统计" class="headerlink" title="阅读量统计"></a>阅读量统计</h3><p>&emsp;&emsp;我用的<a href="https://leancloud.cn/" target="_blank" rel="noopener">LeanCloud</a>，具体操作步骤请直接跳转至<a href="https://notes.wanghao.work/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html#%E9%85%8D%E7%BD%AELeanCloud" target="_blank" rel="noopener"> 为NexT主题添加文章阅读量统计功能</a>。</p><h3 id="内容分享服务"><a href="#内容分享服务" class="headerlink" title="内容分享服务"></a>内容分享服务</h3><p>&emsp;&emsp;我采用的是<a href="https://github.com/revir/need-more-share2" target="_blank" rel="noopener">need-more-share2</a>，直接在主题配置文件里面打开就行。</p><h3 id="搜索服务"><a href="#搜索服务" class="headerlink" title="搜索服务"></a>搜索服务</h3><p>&emsp;&emsp;我采用的是<a href="https://swiftype.com/" target="_blank" rel="noopener">Swiftype</a>，具体步骤请按照<a href="http://theme-next.iissnan.com/third-party-services.html" target="_blank" rel="noopener">next的官方文档</a>操作。</p><h3 id="网站收录"><a href="#网站收录" class="headerlink" title="网站收录"></a>网站收录</h3><p>&emsp;&emsp;<a href="https://www.google.com/webmasters/tools/" target="_blank" rel="noopener">Google Webmaster tools</a>收录特别快，具体步骤请按照<a href="http://theme-next.iissnan.com/third-party-services.html" target="_blank" rel="noopener">next的官方文档</a>操作。但是<a href="http://ziyuan.baidu.com/?castk=LTE%3D" target="_blank" rel="noopener">百度站长</a>收录的就很慢了，我的到现在还没被收录。</p><h3 id="其他服务"><a href="#其他服务" class="headerlink" title="其他服务"></a>其他服务</h3><p>&emsp;&emsp;NexT 借助于 MathJax 来显示数学公式，此选项默认关闭，如果博客中有公式，那么一定要打开这个选项。</p><h2 id="next进阶"><a href="#next进阶" class="headerlink" title="next进阶"></a>next进阶</h2><p>&emsp;&emsp;最后想说一下其他一些配置，比如添加背景图片、侧边栏头像旋转、侧边栏鼠标滑入显示、背景音乐等等，此处大部分参考<a href="http://mashirosorata.vicp.io/HEXO-NEXT%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE.html" target="_blank" rel="noopener">这个博客</a>。</p><p>&emsp;&emsp;next人性化的为用户提供了custom接口，我们可以在不影响主题文件的基础上进行个性化定制。</p><h3 id="给页面添加背景图片"><a href="#给页面添加背景图片" class="headerlink" title="给页面添加背景图片"></a>给页面添加背景图片</h3><p>&emsp;&emsp;在theme/next/source/css/_custom文件夹下打开custom.styl文件，往里面添加以下代码：</p><figure class="highlight styl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  background: url(/images/blogbk.jpg) no-repeat;</span><br><span class="line">  <span class="comment">/* 背景图垂直、水平均居中 */</span></span><br><span class="line">  <span class="attribute">background-position</span>: center center;</span><br><span class="line">  <span class="comment">/* 当内容高度大于图片高度时，背景图像的位置相对于viewport固定 */</span></span><br><span class="line">  <span class="attribute">background-attachment</span>: fixed;</span><br><span class="line">  <span class="comment">/* 让背景图基于容器大小伸缩 */</span></span><br><span class="line">  <span class="attribute">background-size</span>: cover;</span><br><span class="line">  <span class="comment">/* 设置背景颜色，背景图加载过程中会显示背景色 */</span></span><br><span class="line">  <span class="attribute">background-color</span>: rgba(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其中的css样式属性都可以根据你的自定义图片来更改，以达到最佳的效果。</p><h3 id="给侧边栏添加背景图片"><a href="#给侧边栏添加背景图片" class="headerlink" title="给侧边栏添加背景图片"></a>给侧边栏添加背景图片</h3><p>&emsp;&emsp;在theme/next/source/css/_custom文件夹下打开custom.styl文件，往里面添加以下代码：</p><figure class="highlight styl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#sidebar</span> &#123;</span><br><span class="line">            background:url(/images/sidebar.jpg);</span><br><span class="line">            <span class="attribute">background-size</span>: cover;</span><br><span class="line">            <span class="attribute">background-position</span>:center;</span><br><span class="line">            <span class="attribute">background-repeat</span>:no-repeat;</span><br><span class="line">            <span class="selector-tag">p</span>,<span class="selector-tag">span</span>,<span class="selector-tag">a</span> &#123;<span class="attribute">color</span>: rgba(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">1</span>);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文字背景色以及半透明的设置"><a href="#文字背景色以及半透明的设置" class="headerlink" title="文字背景色以及半透明的设置"></a>文字背景色以及半透明的设置</h3><p>&emsp;&emsp;在theme/next/source/css/_custom文件夹下打开custom.styl文件，往里面添加以下代码：</p><figure class="highlight styl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.content</span> &#123;</span><br><span class="line">            <span class="attribute">border-radius</span>: <span class="number">20px</span>;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">30px</span> <span class="number">60px</span> <span class="number">30px</span> <span class="number">60px</span>;</span><br><span class="line">            <span class="attribute">background</span>:rgba(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.8</span>) none repeat scroll !important;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其中border-radius是给文章背景设置圆角，margin-top是设置文章到顶部的距离，其中属性可根据自己的需要进行调整。</p><h3 id="评论-来必力-添加背景色"><a href="#评论-来必力-添加背景色" class="headerlink" title="评论(来必力)添加背景色"></a>评论(来必力)添加背景色</h3><p>&emsp;&emsp;在theme/next/source/css/_custom文件夹下打开custom.styl文件，往里面添加以下代码：</p><figure class="highlight styl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#lv-container</span> &#123;</span><br><span class="line">       <span class="attribute">border-radius</span>: <span class="number">20px</span>;</span><br><span class="line">   <span class="attribute">padding</span>: <span class="number">30px</span> <span class="number">60px</span> <span class="number">30px</span> <span class="number">60px</span>;</span><br><span class="line">       <span class="attribute">background</span>:rgba(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.8</span>) none repeat scroll !important;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;和上面一样，背景色和圆角可自己调整更改。</p><h3 id="实现点击出现桃心效果"><a href="#实现点击出现桃心效果" class="headerlink" title="实现点击出现桃心效果"></a>实现点击出现桃心效果</h3><p>&emsp;&emsp;在网址输入如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://7u2ss1.com1.z0.glb.clouddn.com/love.js</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后将里面的代码copy一下，新建love.js文件并且将代码复制进去，然后保存。将love.js文件放到路径/themes/next/source/js/src里面，然后打开\themes\next\layout_layout.swig文件,在末尾（在前面引用会出现找不到的bug）添加以下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 页面点击小红心 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"/js/src/love.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="侧边栏头像旋转"><a href="#侧边栏头像旋转" class="headerlink" title="侧边栏头像旋转"></a>侧边栏头像旋转</h3><p>&emsp;&emsp;打开\themes\next\source\css_common\components\sidebar\sidebar-author.styl，在里面添加如下代码：</p><figure class="highlight styl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.site-author-image</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="variable">$site</span>-author-image-padding;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="variable">$site</span>-author-image-width;</span><br><span class="line">  <span class="attribute">height</span>: <span class="variable">$site</span>-author-image-height;</span><br><span class="line">  <span class="attribute">border</span>: <span class="variable">$site</span>-author-image-border-width solid <span class="variable">$site</span>-author-image-border-color;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* start*/</span></span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span></span><br><span class="line">  webkit-<span class="attribute">transition</span>: <span class="number">1.4s</span> all;</span><br><span class="line">  moz-<span class="attribute">transition</span>: <span class="number">1.4s</span> all;</span><br><span class="line">  ms-<span class="attribute">transition</span>: <span class="number">1.4s</span> all;</span><br><span class="line">  <span class="attribute">transition</span>: <span class="number">1.4s</span> all;</span><br><span class="line">  <span class="comment">/* end */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* start */</span></span><br><span class="line"><span class="selector-class">.site-author-image</span>:hover &#123;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#55DAE1</span>;</span><br><span class="line">  webkit-<span class="attribute">transform</span>: rotate(<span class="number">360deg</span>) scale(<span class="number">1.1</span>);</span><br><span class="line">  moz-<span class="attribute">transform</span>: rotate(<span class="number">360deg</span>) scale(<span class="number">1.1</span>);</span><br><span class="line">  ms-<span class="attribute">transform</span>: rotate(<span class="number">360deg</span>) scale(<span class="number">1.1</span>);</span><br><span class="line">  <span class="attribute">transform</span>: rotate(<span class="number">360deg</span>) scale(<span class="number">1.1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* end */</span></span><br></pre></td></tr></table></figure><h3 id="设置鼠标划入侧边栏才显示站点信息："><a href="#设置鼠标划入侧边栏才显示站点信息：" class="headerlink" title="设置鼠标划入侧边栏才显示站点信息："></a>设置鼠标划入侧边栏才显示站点信息：</h3><h4 id="设置自定义div"><a href="#设置自定义div" class="headerlink" title="设置自定义div"></a>设置自定义div</h4><p>&emsp;&emsp;在theme/next/layout/_macro文件夹下打开sidebar.swig文件，找到以下代码行的位置：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">"site-state motion-element"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在其上添加以下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--my custom code begin--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.0/jquery.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/velocity/1.5.0/velocity.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  $("#sidebar").hover(function()&#123;</span></span><br><span class="line"><span class="undefined">    $("#mydivshow").velocity('stop').velocity(&#123;opacity: 1&#125;);</span></span><br><span class="line"><span class="undefined">  &#125;,function()&#123;</span></span><br><span class="line"><span class="undefined">    $("#mydivshow").velocity('stop').velocity(&#123;opacity: 0&#125;);</span></span><br><span class="line"><span class="undefined">  &#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"mydivshow"</span> <span class="attr">class</span>=<span class="string">"mydivshow"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--my custom code end--&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后找到代码行：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">&#123;% if display_toc and toc(page.content).length &gt; 1 %&#125;</span><br><span class="line"><span class="comment">&lt;!--noindex--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"post-toc-wrap motion-element sidebar-panel sidebar-panel-active"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在此的上方添加一个，如下所示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--my custom code begin--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--my custom code end--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">&#123;% if display_toc and toc(page.content).length &gt; 1 %&#125;</span><br><span class="line"><span class="comment">&lt;!--noindex--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"post-toc-wrap motion-element sidebar-panel sidebar-panel-active"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"post-toc"</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="自定义区域的初始化设置"><a href="#自定义区域的初始化设置" class="headerlink" title="自定义区域的初始化设置"></a>自定义区域的初始化设置</h4><p>&emsp;&emsp;在theme/next/source/css/_custom文件夹下打开custom.styl文件，向里面增添下列代码：</p><figure class="highlight styl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#mydivshow&#123;<span class="attribute">opacity</span>: <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure><p>注：具体代码添加位置以及代码里的section.site-overview可以自己修改，<div id="mydivshow" class="mydivshow">和末尾的</div>是控制显示区域，section.site-overview则是用户鼠标滑入划出时的触发事件区域。</p><h3 id="自定义音乐播放器"><a href="#自定义音乐播放器" class="headerlink" title="自定义音乐播放器"></a>自定义音乐播放器</h3><p>&emsp;&emsp;描述：本站所用的音乐播放器是由DIYgod所制作的APlayer，其详细资料可参见<a href="https://aplayer.js.org/docs/#/" target="_blank" rel="noopener">这里</a>。</p><h4 id="安装APlayer插件"><a href="#安装APlayer插件" class="headerlink" title="安装APlayer插件"></a>安装APlayer插件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install aplayer --save</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;安装完后在node_modules目录下找到APlayer.min.js文件，将其复制到theme/next/source/js/src/目录下。</p><h4 id="生成音乐播放器"><a href="#生成音乐播放器" class="headerlink" title="生成音乐播放器"></a>生成音乐播放器</h4><p>&emsp;&emsp;在你想要加入音乐播放器的地方插入以下代码，本站把他放在了侧边栏里，具体操作如下。</p><p>&emsp;&emsp;打开theme/next/layout/_custom/文件夹下的sidebar.swig文件，向其中添加以下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"player1"</span> <span class="attr">class</span>=<span class="string">"aplayer"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/js/src/APlayer.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">var ap = new APlayer(&#123;</span></span><br><span class="line"><span class="undefined">    element: document.getElementById('player1'),                       // Optional, player element</span></span><br><span class="line"><span class="undefined">    narrow: false,                                                     // Optional, narrow style</span></span><br><span class="line"><span class="undefined">    autoplay: false,                                                    // Optional, autoplay song(s), not supported by mobile browsers</span></span><br><span class="line"><span class="undefined">    showlrc: 0,                                                        // Optional, show lrc, can be 0, 1, 2, see: ###With lrc</span></span><br><span class="line"><span class="undefined">    mutex: true,                                                       // Optional, pause other players when this player playing</span></span><br><span class="line"><span class="undefined">    theme: '#e6d0b2',                                                  // Optional, theme color, default: #b7daff</span></span><br><span class="line"><span class="undefined">    mode: 'random',                                                    // Optional, play mode, can be `random` `single` `circulation`(loop) `order`(no loop), default: `circulation`</span></span><br><span class="line"><span class="undefined">    preload: 'metadata',                                               // Optional, the way to load music, can be 'none' 'metadata' 'auto', default: 'auto'</span></span><br><span class="line"><span class="undefined">    listmaxheight: '513px',                                             // Optional, max height of play list</span></span><br><span class="line"><span class="undefined">    music: &#123;                                                           // Required, music info, see: ###With playlist</span></span><br><span class="line"><span class="undefined">        title: '你曾是少年',                                          // Required, music title</span></span><br><span class="line"><span class="undefined">        author: 'cover',                                              // Required, music author</span></span><br><span class="line"><span class="undefined">        url: 'http://mp3.qqmusic.cc/yq/102426570.mp3',                // Required, music url</span></span><br><span class="line"><span class="undefined">        pic: '/images/visitor.jpg',                                   // Optional, music picture</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">&#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里的歌曲url必须是在线音乐，当时现在大部分播放器都不会曝露出真实的歌曲播放地址，找资源很是费劲。这里给大家推荐一个<a href="http://www.qqmusic.cc/" target="_blank" rel="noopener">解析平台</a>，大部分的qq音乐还是可以解析出来或者直接在该平台上找到播放链接的。大家可以写多个music结构，以此来添加多个音乐。</p><p>&emsp;&emsp;当然，我们还可以通过添加网易云音乐外链的方式在我们的博客中添加音乐。打开theme/next/layout/_custom/文件夹下的sidebar.swig文件，向其中添加以下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"music163player"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">frameborder</span>=<span class="string">"no"</span> <span class="attr">border</span>=<span class="string">"0"</span> <span class="attr">marginwidth</span>=<span class="string">"0"</span> <span class="attr">marginheight</span>=<span class="string">"0"</span> <span class="attr">width</span>=<span class="string">330</span> <span class="attr">height</span>=<span class="string">86</span> <span class="attr">src</span>=<span class="string">"//music.163.com/outchain/player?type=2&amp;id=458789090&amp;auto=0&amp;height=66"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;替换上述代码中的iframe标签之间的内容，就可以替换不同的音乐进行播放了。网易云音乐的歌单也可以生成外链，前提是歌单里的歌曲都有版权哦~</p><h4 id="自定义播放器样式"><a href="#自定义播放器样式" class="headerlink" title="自定义播放器样式"></a>自定义播放器样式</h4><p>&emsp;&emsp;包含颜色更改，列表歌曲信息的排版修改。</p><p>&emsp;&emsp;在theme/next/source/css/_custom文件夹下打开custom.styl文件，往里面添加以下代码：</p><figure class="highlight styl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.aplayer-list</span> <span class="selector-tag">ol</span> <span class="selector-tag">li</span>:hover &#123;   <span class="comment">/*列表悬停颜色*/</span></span><br><span class="line">                  <span class="attribute">background</span>:rgba(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">1</span>) none repeat scroll !important;&#125;</span><br><span class="line"><span class="selector-class">.aplayer-list</span> <span class="selector-tag">ol</span> <span class="selector-tag">li</span> &#123;   <span class="comment">/*列表底色*/</span></span><br><span class="line">                        <span class="attribute">background</span>:rgba(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">1</span>);&#125;</span><br><span class="line"><span class="selector-class">.aplayer-list-light</span> &#123;   <span class="comment">/*列表播放歌曲颜色*/</span></span><br><span class="line">                      <span class="attribute">background</span>:rgba(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">1</span>) none repeat scroll !important;&#125;</span><br><span class="line"><span class="selector-id">#player1</span> &#123;    <span class="comment">/*边框样式*/</span></span><br><span class="line">          <span class="attribute">border-radius</span>: <span class="number">6px</span>;</span><br><span class="line">          <span class="selector-tag">div</span>,<span class="selector-tag">ol</span> &#123;<span class="attribute">border-radius</span>: <span class="number">6px</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="selector-id">#player1</span> *&#123;<span class="attribute">color</span>: rgba(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">1</span>);&#125;    <span class="comment">/*字体颜色*/</span></span><br><span class="line"><span class="comment">/*列表歌曲信息的排版*/</span></span><br><span class="line">.aplayer-list-index&#123;<span class="attribute">float</span>:left;&#125;</span><br><span class="line">.aplayer-list-title&#123;<span class="attribute">float</span>:left;&#125;</span><br><span class="line">.aplayer-list-author&#123;<span class="attribute">float</span>:right;&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义萌萌哒音乐播放控制边栏"><a href="#自定义萌萌哒音乐播放控制边栏" class="headerlink" title="自定义萌萌哒音乐播放控制边栏"></a>自定义萌萌哒音乐播放控制边栏</h3><p>&emsp;&emsp;这一步要在自定义音乐播放器的配置完成之后才能进行，因为aplayer-controler依赖于aplayer来实现播放功能。</p><h4 id="安装aplayer-controler插件"><a href="#安装aplayer-controler插件" class="headerlink" title="安装aplayer-controler插件"></a>安装aplayer-controler插件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install aplayer-controler --save</span><br></pre></td></tr></table></figure><h4 id="添加js代码"><a href="#添加js代码" class="headerlink" title="添加js代码"></a>添加js代码</h4><p>&emsp;&emsp;安装APlayer-Controler的js文件：<a href="https://github.com/Mashiro-Sorata/APlayer-Controler/blob/master/demo/src/Aplayer-Controler.js" target="_blank" rel="noopener">APlayer-Controler.js</a></p><p>&emsp;&emsp;将其放入theme/next/source/js/src下。</p><h4 id="创建按钮区域"><a href="#创建按钮区域" class="headerlink" title="创建按钮区域"></a>创建按钮区域</h4><p>&emsp;&emsp;在theme/next/layout/_custom/文件夹下新建一个myapcontroler.swig的文件。向其中添加以下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/js/src/Aplayer-Controler.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"AP-controler"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">var myapc=new APlayer_Controler(&#123;</span></span><br><span class="line"><span class="undefined">APC_dom:$('#AP-controler'),</span></span><br><span class="line"><span class="undefined">aplayer:ap, //此为绑定的aplayer对象</span></span><br><span class="line"><span class="undefined">attach_right:true,</span></span><br><span class="line"><span class="undefined">position:&#123;top:'300px',bottom:''&#125;,</span></span><br><span class="line"><span class="undefined">fixed:true,</span></span><br><span class="line"><span class="undefined">btn_width:100,</span></span><br><span class="line"><span class="undefined">btn_height:120,</span></span><br><span class="line"><span class="undefined">img_src:['http://oty1v077k.bkt.clouddn.com/bukagirl.jpg',</span></span><br><span class="line"><span class="undefined">'http://oty1v077k.bkt.clouddn.com/jumpgirl.jpg',</span></span><br><span class="line"><span class="undefined">'http://oty1v077k.bkt.clouddn.com/pentigirl.jpg',</span></span><br><span class="line"><span class="undefined">'http://oty1v077k.bkt.clouddn.com/%E8%90%8C1.gif'],</span></span><br><span class="line"><span class="undefined">img_style:&#123;repeat:'no-repeat',position:'center',size:'contain'&#125;,</span></span><br><span class="line"><span class="undefined">ctrls_color:'rgba(173,255,47,0.8)',</span></span><br><span class="line"><span class="undefined">ctrls_hover_color:'rgba(255,140,0,0.7)',</span></span><br><span class="line"><span class="undefined">tips_on:true,</span></span><br><span class="line"><span class="undefined">tips_width:140,</span></span><br><span class="line"><span class="undefined">tips_height:25,</span></span><br><span class="line"><span class="undefined">tips_color:'rgba(255,255,255,0.6)',</span></span><br><span class="line"><span class="undefined">tips_content:&#123;&#125;,</span></span><br><span class="line"><span class="undefined">timeout:30</span></span><br><span class="line"><span class="undefined">&#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="将控制按钮加入body页面"><a href="#将控制按钮加入body页面" class="headerlink" title="将控制按钮加入body页面"></a>将控制按钮加入body页面</h4><p>&emsp;&emsp;在theme/next/layout文件夹下打开_layout.swig文件，在前添加以下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% include '_custom/myapcontroler.swig' %&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;到此，自定义音乐播放控制边栏就基本完成，完成整个配置需要根据自己的主题背景进一步修改完善。</p><hr><p><strong><font color="red" size="3" face="仿宋">本教程到此结束，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;p&gt;[toc]&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;
      
    
    </summary>
    
      <category term="博客搭建" scheme="http://wordzzzz.gitee.io/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="jekyll" scheme="http://wordzzzz.gitee.io/tags/jekyll/"/>
    
      <category term="hexo" scheme="http://wordzzzz.gitee.io/tags/hexo/"/>
    
      <category term="github" scheme="http://wordzzzz.gitee.io/tags/github/"/>
    
      <category term="gitee" scheme="http://wordzzzz.gitee.io/tags/gitee/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法系列之一：八大排序综述</title>
    <link href="http://wordzzzz.gitee.io/2018/01/09/DS/"/>
    <id>http://wordzzzz.gitee.io/2018/01/09/DS/</id>
    <published>2018-01-08T16:00:00.000Z</published>
    <updated>2018-01-09T12:40:01.339Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>个人博客：<a href="https://wordzzzz.github.io/" target="_blank" rel="noopener">https://wordzzzz.github.io/</a> <a href="https://wordzzzz.gitee.io/">https://wordzzzz.gitee.io/</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/DS&amp;A/sort" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/DS&amp;A/sort</a></strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><p>[toc]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;剑指offer刷完了，是时候总结一波数据结构与算法了。本系列文章暂定包括数据结构中树和图的各种操作，以及查找、排序等基本算法和动态规划等高级算法。本系列文章只是作为总结性的文献，为自己日后的面试做准备。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp;直接引自维基百科：<a href="https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">排序算法</a>。总结性强。</p><p>&emsp;&emsp;在计算机科学与数学中，一个排序算法（英语：Sorting algorithm）是一种能将一串数据依照特定排序方式进行排列的一种算法。最常用到的排序方式是数值顺序以及字典顺序。有效的排序算法在一些算法（例如搜索算法与合并算法）中是重要的，如此这些算法才能得到正确解答。排序算法也用在处理文字数据以及产生人类可读的输出结果。基本上，排序算法的输出必须遵守下列两个原则：</p><ul><li>输出结果为递增序列（递增是针对所需的排序顺序而言）</li><li>输出结果是原输入的一种排列、或是重组</li></ul><p>&emsp;&emsp;虽然排序算法是一个简单的问题，但是从计算机科学发展以来，在此问题上已经有大量的研究。举例而言，冒泡排序在1956年就已经被研究。虽然大部分人认为这是一个已经被解决的问题，有用的新算法仍在不断的被发明。（例子：图书馆排序在2004年被发表）</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>&emsp;&emsp;在计算机科学所使用的排序算法通常被分类为：</p><ul><li>计算的时间复杂度（最差、平均、和最好性能），依据列表（list）的大小(n)。一般而言，好的性能是O(n log n)，坏的性能是O(n2)。对于一个排序理想的性能是O(n)，但平均而言不可能达到。基于比较的排序算法对大多数输入而言至少需要O(n log n)。</li><li>内存使用量（以及其他电脑资源的使用）</li><li>稳定性：稳定排序算法会让原本有相等键值的纪录维持相对次序。也就是如果一个排序算法是稳定的，当有两个相等键值的纪录R和S，且在原本的列表中R出现在S之前，在排序过的列表中R也将会是在S之前。</li><li>依据排序的方法：插入、交换、选择、合并等等。</li></ul><h4 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h4><p>&emsp;&emsp;当相等的元素是无法分辨的，比如像是整数，稳定性并不是一个问题。然而，假设以下的数对将要以他们的第一个数字来排序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(4, 1)  (3, 1)  (3, 7)（5, 6）</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这个状况下，有可能产生两种不同的结果，一个是让相等键值的纪录维持相对的次序，而另外一个则没有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(3, 1)  (3, 7)  (4, 1)  (5, 6)  （维持次序）</span><br><span class="line">(3, 7)  (3, 1)  (4, 1)  (5, 6)  （次序被改变）</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;不稳定排序算法可能会在相等的键值中改变纪录的相对次序，但是稳定排序算法从来不会如此。不稳定排序算法可以被特别地实现为稳定。实现的一个方式是人工扩充键值的比较（比如上面的比较中加入第二个标准：第二个键值的大小），从而在键值相同的两个对象之间进行比较时，使用在原先数据次序中的条目。然而，要记录这种次序通常牵涉到额外的空间负担。</p><h3 id="排序算法列表"><a href="#排序算法列表" class="headerlink" title="排序算法列表"></a>排序算法列表</h3><p>&emsp;&emsp;在这个表格中，n是要被排序的纪录数量以及k是不同键值的数量。</p><h4 id="稳定的排序"><a href="#稳定的排序" class="headerlink" title="稳定的排序"></a>稳定的排序</h4><ul><li>冒泡排序（bubble sort）— O(n2)</li><li>插入排序（insertion sort）— O(n2)</li><li>鸡尾酒排序（cocktail sort）— O(n2)</li><li>桶排序（bucket sort）— O(n)；需要O(k)额外空间</li><li>计数排序（counting sort）— O(n+k)；需要O(n+k)额外空间</li><li>归并排序（merge sort）— O(n log n)；需要O(n)额外空间</li><li>原地归并排序 — O(n log2 n)如果使用最佳的现在版本</li><li>二叉排序树排序（binary tree sort）— O(n log n)期望时间；O(n2)最坏时间；需要O(n)额外空间</li><li>鸽巢排序（pigeonhole sort）— O(n+k)；需要O(k)额外空间</li><li>基数排序（radix sort）— O(n·k)；需要O(n)额外空间</li><li>侏儒排序（gnome sort）— O(n2)</li><li>图书馆排序（library sort）— O(n log n)期望时间；O(n2)最坏时间；需要(1+ε)n额外空间</li><li>块排序（block sort）— O(n log n)</li></ul><h4 id="不稳定的排序"><a href="#不稳定的排序" class="headerlink" title="不稳定的排序"></a>不稳定的排序</h4><ul><li>选择排序（selection sort）— O(n2)</li><li>希尔排序（shell sort）— O(n log2 n)如果使用最佳的现在版本</li><li>Clover排序算法（Clover sort）— O(n)期望时间，O(n2)最坏情况</li><li>梳排序 — O(n log n)</li><li>堆排序（heap sort）— O(n log n)</li><li>平滑排序（smooth sort）— O(n log n)</li><li>快速排序（quick sort）— O(n log n)期望时间，O(n2)最坏情况；对于大的、随机数列表一般相信是最快的已知排序</li><li>内省排序（introsort）—O (n log n)</li><li>耐心排序（patience sort）— O(n log n + k)最坏情况时间，需要额外的O(n + k)空间，也需要找到最长的递增子序列（longest increasing subsequence）</li></ul><h4 id="不实用的排序"><a href="#不实用的排序" class="headerlink" title="不实用的排序"></a>不实用的排序</h4><ul><li>Bogo排序 — O(n × n!)，最坏的情况下期望时间为无穷</li><li>Stupid排序 — O(n3);递归版本需要O(n2)额外内存</li><li>珠排序（bead sort）— O(n) or O(√n),但需要特别的硬件</li><li>煎饼排序 — O(n),但需要特别的硬件</li><li>臭皮匠排序（stooge sort）算法简单，但需要约n^2.7的时间</li></ul><hr><p>==概述到此结束，下面分八篇文章依次对典型的八种排序进行图文并茂的讲解和c++实现。==</p><hr><p>&emsp;&emsp;先贴一下八大排序的性能概括图：</p><p>&emsp;&emsp;再贴出来以后要用到的main函数和头文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> len = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(*arr);</span><br><span class="line"><span class="comment">//double arr[] = &#123;4.5, 2.3,6.7, 3.5, 1.1&#125;;</span></span><br><span class="line"><span class="comment">//const int len = sizeof(arr) / sizeof(arr[0]);</span></span><br><span class="line"><span class="comment">//BubbleSort(arr, len);</span></span><br><span class="line"><span class="comment">//BubbleSort1(arr, len);</span></span><br><span class="line"><span class="comment">//BubbleSort2(arr, len);</span></span><br><span class="line"><span class="comment">//BubbleSort3(arr, len);</span></span><br><span class="line"><span class="comment">//InsertSort(arr, len);</span></span><br><span class="line"><span class="comment">//ShellSort(arr, len);</span></span><br><span class="line"><span class="comment">//QuickSort(arr, len);</span></span><br><span class="line"><span class="comment">//QuickSortIteration(arr, len);</span></span><br><span class="line"><span class="comment">//SelectSort(arr, len);</span></span><br><span class="line"><span class="comment">//HeapSort(arr, len);</span></span><br><span class="line"><span class="comment">//MergeSort(arr, len); </span></span><br><span class="line">MergeSortIteration(arr, len);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> v : arr)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125; <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;最后就要打开传送门了：</p><p>csdn告诉我今天上传博客的次数到达上限了，然而我还有两个没有上传，那我只好先引流到我的个人博客了。</p><ul><li><a href="https://wordzzzz.github.io/2018/01/01/DS/" target="_blank" rel="noopener">插入排序</a>：（有序区，无序区）。把无序区的第一个元素插入到有序区的合适的位置。对数组：比较得少，换得多。</li><li><a href="https://wordzzzz.github.io/2018/01/02/DS/" target="_blank" rel="noopener">希尔排序</a>：每一轮按照事先决定的间隔进行插入排序，间隔会依次缩小，最后一次一定要是1。</li><li><a href="https://wordzzzz.github.io/2018/01/03/DS/" target="_blank" rel="noopener">选择排序</a>：（有序区，无序区）。在无序区里找一个最小的元素跟在有序区的后面。对数组：比较得多，换得少。</li><li><a href="https://wordzzzz.github.io/2018/01/04/DS/" target="_blank" rel="noopener">堆排序</a>：（最大堆，有序区）。<br>从堆顶把根卸出来放在有序区之前，再恢复堆。</li><li><a href="https://wordzzzz.github.io/2018/01/05/DS/" target="_blank" rel="noopener">冒泡排序</a>：（无序区，有序区）。从无序区通过交换找出最大元素放到有序区前端。</li><li><a href="https://wordzzzz.github.io/2018/01/06/DS/" target="_blank" rel="noopener">快速排序</a>：（小数，基准元素，大数）。<br>在区间中随机挑选一个元素作基准，将小于基准的元素放在基准之前，大于基准的元素放在基准之后，再分别对小数区与大数区进行排序。</li><li><a href="https://wordzzzz.github.io/2018/01/07/DS/" target="_blank" rel="noopener">归并排序</a>：把数据分为两段，从两段中逐个选最小的元素移入新数据段的末尾。<br>可从上到下或从下到上进行。</li><li><a href="https://wordzzzz.github.io/2018/01/08/DS/" target="_blank" rel="noopener">基数排序</a>：一种多关键字的排序算法，可用桶排序实现。</li></ul><p>参考链接：<br><a href="https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">维基百科</a><br><a href="https://visualgo.net/en/sorting" target="_blank" rel="noopener">数据结构与算法可视化可视化</a><br><a href="http://www.cnblogs.com/skywang12345/category/508186.html" target="_blank" rel="noopener">数据结构与算法</a><br><a href="http://www.open-open.com/lib/view/open1404781467544.html" target="_blank" rel="noopener">排序算法可视化</a><br><a href="http://wuchong.me/blog/2014/02/09/algorithm-sort-summary/" target="_blank" rel="noopener">经典排序算法总结与实现</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://wordzzzz.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序" scheme="http://wordzzzz.gitee.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法系列之一：八大排序之基数排序</title>
    <link href="http://wordzzzz.gitee.io/2018/01/08/DS/"/>
    <id>http://wordzzzz.gitee.io/2018/01/08/DS/</id>
    <published>2018-01-07T16:00:00.000Z</published>
    <updated>2018-01-09T12:39:52.968Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>个人博客：<a href="https://wordzzzz.github.io/" target="_blank" rel="noopener">https://wordzzzz.github.io/</a> &amp;&amp; <a href="https://wordzzzz.gitee.io/">https://wordzzzz.gitee.io/</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/DS-A" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/DS-A</a></strong></li><li><strong>博客作者：WordZzzz，一只热爱技术的文艺青年</strong></li></ul><hr><p>[toc]</p><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;建议先看排序综述，传送门：<a href="http://blog.csdn.net/u011475210/article/details/79014021" target="_blank" rel="noopener">数据结构与算法系列之一：八大排序综述</a>。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>&emsp;&emsp;基数排序（英语：Radix sort）是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。基数排序的发明可以追溯到1887年赫尔曼·何乐礼在打孔卡片制表机（Tabulation Machine）上的贡献。</p><p>&emsp;&emsp;基数排序法会使用到桶 (Bucket)，顾名思义，通过将要比较的位（个位、十位、百位…），将要排序的元素分配至 0~9 个桶中，借以达到排序的作用，在某些时候，基数排序法的效率高于其它的比较性排序法。</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>&emsp;&emsp;它是这样实现的：</p><ul><li>将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。</li><li>然后，从最低位开始，依次进行一次排序。</li><li>这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。</li></ul><p>&emsp;&emsp;基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。</p><h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>&emsp;&emsp;wordzzzz的小数据规模演示：</p><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20180109153959062?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="radixsort from wordzzzz"></div><br><p></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 获取数组a中最大值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_max</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">const</span> <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, max;</span><br><span class="line"></span><br><span class="line">max = <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; length; i++)</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[i] &gt; max)</span><br><span class="line">max = <span class="built_in">array</span>[i];</span><br><span class="line"><span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 对数组按照"某个位数"进行排序(桶排序)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">count_sort</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">const</span> <span class="keyword">int</span> length, <span class="keyword">int</span> <span class="built_in">exp</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">T* output = (T*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(T) * length);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (output == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fputs</span>(<span class="string">"Error: out of memory\n"</span>, <span class="built_in">stderr</span>);</span><br><span class="line"><span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> i, buckets[<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++)<span class="comment">// 将数据出现的次数存储在buckets[]中</span></span><br><span class="line">buckets[(<span class="built_in">array</span>[i] / <span class="built_in">exp</span>) % <span class="number">10</span>]++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)<span class="comment">// 更改buckets[i]。目的是让更改后的buckets[i]的值，是该数据在output[]中的位置。</span></span><br><span class="line">buckets[i] += buckets[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)<span class="comment">// 将数据存储到临时数组output[]中，这里的对应关系一定要捋清楚</span></span><br><span class="line">output[--buckets[(<span class="built_in">array</span>[i] / <span class="built_in">exp</span>) % <span class="number">10</span>]] = <span class="built_in">array</span>[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++)<span class="comment">// 将排序好的数据赋值给array[]</span></span><br><span class="line"><span class="built_in">array</span>[i] = output[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 基数排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RadixSort</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">const</span> <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">exp</span>;<span class="comment">// 指数。当对数组按各位进行排序时，exp=1；按十位进行排序时，exp=10；...</span></span><br><span class="line"><span class="keyword">int</span> max = get_max(<span class="built_in">array</span>, length);<span class="comment">// 数组array中的最大值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">exp</span> = <span class="number">1</span>; max / <span class="built_in">exp</span> &gt; <span class="number">0</span>; <span class="built_in">exp</span> *= <span class="number">10</span>)<span class="comment">// 从个位开始，对数组array按"指数"进行排序</span></span><br><span class="line">count_sort(<span class="built_in">array</span>, length, <span class="built_in">exp</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><ul><li>数据结构    数组</li><li>平均时间复杂度 $O(d*(n+r))$</li><li>最好情况 $O(d*(n+r))$</li><li>最坏情况 $O(d*(n+r))$</li><li>空间复杂度 $O(n+r)$</li></ul><p>&emsp;&emsp;其中，d 为位数，r 为基数，n 为原数组个数。在基数排序中，因为没有比较操作，所以在复杂上，最好的情况与最坏的情况在时间上是一致的，均为 O(d*(n + r))。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>&emsp;&emsp;如果捋不清上述代码中的数组对应关系，可以参考一下下面这两张图的讲解，来源：<a href="http://www.cnblogs.com/skywang12345/p/3603669.html。" target="_blank" rel="noopener">http://www.cnblogs.com/skywang12345/p/3603669.html。</a></p><ul><li>个位的数值范围是[0,10)。因此，参见桶数组buckets[]，将数组按照个位数值添加到桶中。</li></ul><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20180109154616722?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="step1"></div><br><p></p><ul><li>接着是根据桶数组buckets[]来进行排序。假设将排序后的数组存在output[]中；找出output[]和buckets[]之间的联系就可以对数据进行排序了。</li></ul><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20180109154657318?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="step2"></div><br><p></p><p>&emsp;&emsp;基数排序不改变相同元素之间的相对顺序，因此它是稳定的排序算法。</p><p>&emsp;&emsp;基数排序 vs 计数排序 vs 桶排序</p><p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p><ul><li>基数排序：根据键值的每位数字来分配桶</li><li>计数排序：每个桶只存储单一键值</li><li>桶排序：每个桶存储一定范围的数值</li></ul><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://wordzzzz.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序" scheme="http://wordzzzz.gitee.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="基数排序" scheme="http://wordzzzz.gitee.io/tags/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法系列之一：八大排序之归并排序</title>
    <link href="http://wordzzzz.gitee.io/2018/01/07/DS/"/>
    <id>http://wordzzzz.gitee.io/2018/01/07/DS/</id>
    <published>2018-01-06T16:00:00.000Z</published>
    <updated>2018-01-09T12:39:43.555Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>个人博客：<a href="https://wordzzzz.github.io/" target="_blank" rel="noopener">https://wordzzzz.github.io/</a> &amp;&amp; <a href="https://wordzzzz.gitee.io/">https://wordzzzz.gitee.io/</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/DS-A" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/DS-A</a></strong></li><li><strong>博客作者：WordZzzz，一只热爱技术的文艺青年</strong></li></ul><hr><p>[toc]</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;建议先看排序综述，传送门：<a href="http://blog.csdn.net/u011475210/article/details/79014021" target="_blank" rel="noopener">数据结构与算法系列之一：八大排序综述</a>。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>&emsp;&emsp;归并排序（英语：Merge sort，或mergesort），是创建在归并操作上的一种有效的排序算法，效率为 ${\displaystyle O(n\log n)}$ 。1945年由约翰·冯·诺伊曼首次提出。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>&emsp;&emsp;归并操作（merge），也叫归并算法，指的是将两个已经排序的序列合并成一个序列的操作。归并排序算法依赖归并操作。</p><p>递归法（Bottom-up）<br>原理如下（假设序列共有 ${\displaystyle n}$ 个元素）：</p><ul><li>将序列每相邻两个数字进行归并操作，形成 ${\displaystyle ceil(n/2)}$ 个序列，排序后每个序列包含两/一个元素。</li><li>若此时序列数不是1个则将上述序列再次归并，形成 ${\displaystyle ceil(n/4)}$个序列，每个序列包含四/三个元素。</li><li>重复步骤2，直到所有元素排序完毕，即序列数为1。</li></ul><p>迭代法（Top-down）</p><ul><li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列。</li><li>设定两个指针，最初位置分别为两个已经排序序列的起始位置。</li><li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置。</li><li>重复步骤3直到某一指针到达序列尾。</li><li>将另一序列剩下的所有元素直接复制到合并序列尾。</li></ul><h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>&emsp;&emsp;wikipedia的大数据规模演示：</p><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20180109111825567?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="merge from wikipedia"></div><br><p></p><p>&emsp;&emsp;wordzzzz的小数据规模演示：</p><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20180109111851701?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="bubblesort from wordzzzz"></div><br><p></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="递归版"><a href="#递归版" class="headerlink" title="递归版"></a>递归版</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 归并排序递归版</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(T *<span class="built_in">array</span>, T *reg, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> left1 = left, right1 = mid;</span><br><span class="line"><span class="keyword">int</span> left2 = mid + <span class="number">1</span>, right2 = right;</span><br><span class="line"><span class="keyword">int</span> k = left;</span><br><span class="line"><span class="keyword">while</span> (left1 &lt;= right1 &amp;&amp; left2 &lt;= right2)</span><br><span class="line">reg[k++] = <span class="built_in">array</span>[left1] &lt; <span class="built_in">array</span>[left2] ? <span class="built_in">array</span>[left1++] : <span class="built_in">array</span>[left2++];</span><br><span class="line"><span class="keyword">while</span> (left1 &lt;= right1)</span><br><span class="line">reg[k++] = <span class="built_in">array</span>[left1++];</span><br><span class="line"><span class="keyword">while</span> (left2 &lt;= right2)</span><br><span class="line">reg[k++] = <span class="built_in">array</span>[left2++];</span><br><span class="line"><span class="keyword">for</span> (k = left; k &lt;= right; k++)</span><br><span class="line"><span class="built_in">array</span>[k] = reg[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSortRecursive</span><span class="params">(T *<span class="built_in">array</span>, T *reg, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left &gt;= right)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">MergeSortRecursive(<span class="built_in">array</span>, reg, left, mid);<span class="comment">//左序列排序</span></span><br><span class="line">MergeSortRecursive(<span class="built_in">array</span>, reg, mid + <span class="number">1</span>, right);<span class="comment">//右序列排序</span></span><br><span class="line">Merge(<span class="built_in">array</span>, reg, left, mid, right);<span class="comment">//合并左右序列</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">const</span> <span class="keyword">int</span> length)</span> </span>&#123; </span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span> == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">throw</span> invalid_argument(<span class="string">"Array must not be empty"</span>); </span><br><span class="line"><span class="keyword">if</span> (length &lt;= <span class="number">0</span>) </span><br><span class="line"><span class="keyword">return</span>; </span><br><span class="line">T* reg = (T*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(T) * length);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (reg == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fputs</span>(<span class="string">"Error: out of memory\n"</span>, <span class="built_in">stderr</span>);</span><br><span class="line"><span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line">MergeSortRecursive(<span class="built_in">array</span>, reg, <span class="number">0</span>, length - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">delete</span>[] reg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="迭代版"><a href="#迭代版" class="headerlink" title="迭代版"></a>迭代版</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 归并排序迭代版</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSortIteration</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">const</span> <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span> == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">throw</span> invalid_argument(<span class="string">"Array must not be empty"</span>);</span><br><span class="line"><span class="keyword">if</span> (length &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">T* regB = (T*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(T) * length);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (regB == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">"Error: out of memory\n"</span>, <span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> seg = <span class="number">1</span>; seg &lt; length; seg += seg) &#123;<span class="comment">//步长，每次翻倍</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> left = <span class="number">0</span>; left &lt; length; left += seg + seg) &#123;</span><br><span class="line"><span class="keyword">int</span> low = left, mid = min(left + seg, length), high = min(left + seg + seg, length);<span class="comment">//因为可能会超出length</span></span><br><span class="line"><span class="keyword">int</span> k = low;</span><br><span class="line"><span class="keyword">int</span> left1 = low, right1 = mid;</span><br><span class="line"><span class="keyword">int</span> left2 = mid, right2 = high;</span><br><span class="line"><span class="keyword">while</span> (left1 &lt; right1 &amp;&amp; left2 &lt; right2)<span class="comment">//这里的表达式没有等号，都是左闭右开区间</span></span><br><span class="line">regB[k++] = <span class="built_in">array</span>[left1] &lt; <span class="built_in">array</span>[left2] ? <span class="built_in">array</span>[left1++] : <span class="built_in">array</span>[left2++];</span><br><span class="line"><span class="keyword">while</span> (left1 &lt; right1)</span><br><span class="line">regB[k++] = <span class="built_in">array</span>[left1++];</span><br><span class="line"><span class="keyword">while</span> (left2 &lt; right2)</span><br><span class="line">regB[k++] = <span class="built_in">array</span>[left2++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)<span class="comment">//更新array</span></span><br><span class="line"><span class="built_in">array</span>[i] = regB[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[] regB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><ul><li>数据结构    数组</li><li>最坏时间复杂度    ${\displaystyle O(n\log n)}$ </li><li>最优时间复杂度    ${\displaystyle O(n)}$ </li><li>平均时间复杂度    ${\displaystyle O(n\log n)}$ </li><li>空间复杂度    ${\displaystyle O(n)}$</li></ul><p>&emsp;&emsp;比较操作的次数介于 ${\displaystyle (n\log n)/2}$ 和 ${\displaystyle n\log n-n+1}$ 。 赋值操作的次数是 ${\displaystyle (2n\log n)}$ 。归并算法的空间复杂度为： ${\displaystyle \Theta (n)}$。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>&emsp;&emsp;对于归并排序有几点说明：</p><ul><li>和快速排序一样，归并排序在小数组上面的表现不如插入排序。</li><li>辅助数组是一个共用的数组。如果在每个归并的过程中都申请一个临时数组会造成比较大的时间开销。</li><li>归并的过程需要将元素复制到辅助数组，再从辅助数组排序复制回原数组，会拖慢排序速度。</li></ul><p>&emsp;&emsp;归并排序有以下几点优化方法：</p><ul><li>和快速排序一样，对于小数组可以使用插入排序或者选择排序，避免递归调用。（代码见下面的归并排序递归版优化）</li><li>在merge()调用之前，可以判断一下a[mid]是否小于等于a[mid+1]。如果是的话那么就不用归并了，数组已经是有序的。原因很简单，既然两个子数组已经有序了，那么a[mid]是第一个子数组的最大值，a[mid+1]是第二个子数组的最小值。当a[mid]&lt;=a[mid+1]时，数组整体有序。</li><li>为了节省将元素复制到辅助数组作用的时间，可以在递归调用的每个层次交换原始数组与辅助数组的角色。（代码见下面的归并排序迭代版优化）</li></ul><h4 id="递归版优化"><a href="#递归版优化" class="headerlink" title="递归版优化"></a>递归版优化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 归并排序递归版合并函数</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(T *<span class="built_in">array</span>, T *reg, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> left1 = left, right1 = mid;</span><br><span class="line"><span class="keyword">int</span> left2 = mid + <span class="number">1</span>, right2 = right;</span><br><span class="line"><span class="keyword">int</span> k = left;</span><br><span class="line"><span class="keyword">while</span> (left1 &lt;= right1 &amp;&amp; left2 &lt;= right2)</span><br><span class="line">reg[k++] = <span class="built_in">array</span>[left1] &lt; <span class="built_in">array</span>[left2] ? <span class="built_in">array</span>[left1++] : <span class="built_in">array</span>[left2++];</span><br><span class="line"><span class="keyword">while</span> (left1 &lt;= right1)</span><br><span class="line">reg[k++] = <span class="built_in">array</span>[left1++];</span><br><span class="line"><span class="keyword">while</span> (left2 &lt;= right2)</span><br><span class="line">reg[k++] = <span class="built_in">array</span>[left2++];</span><br><span class="line"><span class="keyword">for</span> (k = left; k &lt;= right; k++)</span><br><span class="line"><span class="built_in">array</span>[k] = reg[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 归并排序递归版递归函数优化</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSortRecursive1</span><span class="params">(T *<span class="built_in">array</span>, T *reg, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left &gt;= right)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (right - left &lt;= M)<span class="comment">//序列长度小于阈值就采用插入排序</span></span><br><span class="line">InsertSort(<span class="built_in">array</span>, left, right);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">MergeSortRecursive1(<span class="built_in">array</span>, reg, left, mid);<span class="comment">//左序列排序</span></span><br><span class="line">MergeSortRecursive1(<span class="built_in">array</span>, reg, mid + <span class="number">1</span>, right);<span class="comment">//右序列排序</span></span><br><span class="line">Merge(<span class="built_in">array</span>, reg, left, mid, right);<span class="comment">//合并左右序列</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">const</span> <span class="keyword">int</span> length)</span> </span>&#123; </span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span> == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">throw</span> invalid_argument(<span class="string">"Array must not be empty"</span>); </span><br><span class="line"><span class="keyword">if</span> (length &lt;= <span class="number">0</span>) </span><br><span class="line"><span class="keyword">return</span>; </span><br><span class="line">T* reg = (T*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(T) * length);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (reg == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fputs</span>(<span class="string">"Error: out of memory\n"</span>, <span class="built_in">stderr</span>);</span><br><span class="line"><span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line">MergeSortRecursive1(<span class="built_in">array</span>, reg, <span class="number">0</span>, length - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">delete</span>[] reg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="迭代版优化"><a href="#迭代版优化" class="headerlink" title="迭代版优化"></a>迭代版优化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 归并排序迭代版优化</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSortIteration1</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">const</span> <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span> == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">throw</span> invalid_argument(<span class="string">"Array must not be empty"</span>);</span><br><span class="line"><span class="keyword">if</span> (length &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">T* regA = <span class="built_in">array</span>;</span><br><span class="line">T* regB = (T*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(T) * length);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (regB == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fputs</span>(<span class="string">"Error: out of memory\n"</span>, <span class="built_in">stderr</span>);</span><br><span class="line"><span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> seg = <span class="number">1</span>; seg &lt; length; seg += seg) &#123;<span class="comment">//步长，每次翻倍</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> left = <span class="number">0</span>; left &lt; length; left += seg + seg) &#123;</span><br><span class="line"><span class="keyword">int</span> low = left, mid = min(left + seg, length), high = min(left + seg + seg, length);<span class="comment">//因为可能会超出length</span></span><br><span class="line"><span class="keyword">int</span> k = low;</span><br><span class="line"><span class="keyword">int</span> left1 = low, right1 = mid;</span><br><span class="line"><span class="keyword">int</span> left2 = mid, right2 = high;</span><br><span class="line"><span class="keyword">while</span> (left1 &lt; right1 &amp;&amp; left2 &lt; right2)<span class="comment">//这里的表达式没有等号，都是左闭右开区间</span></span><br><span class="line">regB[k++] = regA[left1] &lt; regA[left2] ? regA[left1++] : regA[left2++];</span><br><span class="line"><span class="keyword">while</span> (left1 &lt; right1)</span><br><span class="line">regB[k++] = regA[left1++];</span><br><span class="line"><span class="keyword">while</span> (left2 &lt; right2)</span><br><span class="line">regB[k++] = regA[left2++];</span><br><span class="line">&#125;</span><br><span class="line">T* temp = regA;<span class="comment">//优化：交换辅助数组与原始数组的角色</span></span><br><span class="line">regA = regB;</span><br><span class="line">regB = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (regA != <span class="built_in">array</span>) &#123;<span class="comment">//如果regA != array，则说明现在regA是辅助数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)<span class="comment">//所以需要拷贝数据到regB，也就是array。</span></span><br><span class="line">regB[i] = regA[i];</span><br><span class="line">regB = regA;<span class="comment">//regB重新指向辅助数组</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[] regB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://wordzzzz.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序" scheme="http://wordzzzz.gitee.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="归并排序" scheme="http://wordzzzz.gitee.io/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法系列之一：八大排序之快速排序</title>
    <link href="http://wordzzzz.gitee.io/2018/01/06/DS/"/>
    <id>http://wordzzzz.gitee.io/2018/01/06/DS/</id>
    <published>2018-01-05T16:00:00.000Z</published>
    <updated>2018-01-09T12:39:23.743Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>个人博客：<a href="https://wordzzzz.github.io/" target="_blank" rel="noopener">https://wordzzzz.github.io/</a> &amp;&amp; <a href="https://wordzzzz.gitee.io/">https://wordzzzz.gitee.io/</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/DS-A" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/DS-A</a></strong></li><li><strong>博客作者：WordZzzz，一只热爱技术的文艺青年</strong></li></ul><hr><p>[toc]</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;建议先看排序综述，传送门：<a href="http://blog.csdn.net/u011475210/article/details/79014021" target="_blank" rel="noopener">数据结构与算法系列之一：八大排序综述</a>。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>&emsp;&emsp;快速排序（英语：Quicksort），又称划分交换排序（partition-exchange sort），一种排序算法，最早由东尼·霍尔提出。在平均状况下，排序 ${\displaystyle n}$ 个项目要 ${\displaystyle O(n\log n)}$ （大O符号）次比较。在最坏状况下则需要 ${\displaystyle O(n^{2})}$ 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 ${\displaystyle O(n\log n)}$ 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>&emsp;&emsp;快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）。</p><p>&emsp;&emsp;步骤为：</p><ul><li>从数列中挑出一个元素，称为”基准”（pivot）.</li><li>重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</li><li>递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li><li>递归到最底部时，数列的大小是零或一，也就是已经排序好了。这个算法一定会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</li></ul><p>&emsp;&emsp;wikipedia的大数据规模演示：</p><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20180108223019362?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="quicksort from wikipedia"></div><br><p></p><p>&emsp;&emsp;wordzzzz的小数据规模演示：</p><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20180108223101863?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="quicksort from wordzzzz"></div><br><p></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>&emsp;&emsp;先给出公用接口，之后的三个递归实现和一个迭代实现在代码中都有详细的说明，我就不再在此赘述。</p><h4 id="公用接口"><a href="#公用接口" class="headerlink" title="公用接口"></a>公用接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 快速排序主体函数（递归）</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt; </span><br><span class="line">void QuickSort(T *array, const int length) &#123; </span><br><span class="line">if (array == NULL)</span><br><span class="line">throw invalid_argument(&quot;Array must not be empty&quot;); </span><br><span class="line">if (length &lt;= 0) </span><br><span class="line">return; </span><br><span class="line"></span><br><span class="line">Partion1(array, 0, length - 1);</span><br><span class="line">//  Partion2(array, 0, length - 1);</span><br><span class="line">//  Partion3(array, 0, length - 1);</span><br><span class="line">//PartionInsert(array, 0, length - 1);</span><br><span class="line">//PartionSecond(array, 0, length - 1);</span><br><span class="line">//PartionThird(array, 0, length - 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 快速排序1：</span></span><br><span class="line"><span class="comment"> * 将第一个元素array[left]提出来作pivot，i=left(该索引之前的数比pivot小，初始值为left)，</span></span><br><span class="line"><span class="comment"> * j从left+1开始遍历数组，找到一个比pivot小的数，i+1，如果i和j序列号不等就交换（小值到前）。</span></span><br><span class="line"><span class="comment"> * j到最右端之后，for循环结束，再把pivot与i所指数据做交换，当前pivot就到达了它的最终位置。</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Partion1</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left &gt;= right)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = left;</span><br><span class="line"><span class="keyword">int</span> j = left + <span class="number">1</span>;</span><br><span class="line">T pivot = <span class="built_in">array</span>[left];<span class="comment">// 取第一个数为基准</span></span><br><span class="line"><span class="keyword">for</span> (; j &lt;= right; ++j)&#123;<span class="comment">// 循环直至 j 扫描至 right</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[j] &lt; pivot)&#123;<span class="comment">// 如果遇到比基准小的数，i右移一位</span></span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">if</span> (j != i)&#123;<span class="comment">// 如果i与j不重合，则交换他们指向的值</span></span><br><span class="line">swap(<span class="built_in">array</span>[j],<span class="built_in">array</span>[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">swap(<span class="built_in">array</span>[left], <span class="built_in">array</span>[i]);<span class="comment">// 基准值的位置确定</span></span><br><span class="line">Partion1(<span class="built_in">array</span>, left, i - <span class="number">1</span>);</span><br><span class="line">Partion1(<span class="built_in">array</span>, i + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 快速排序2：</span></span><br><span class="line"><span class="comment"> * 将第一个元素array[left]提出来作pivot，i = left+1从左向右遍历找到一个比pivot大的数停止，</span></span><br><span class="line"><span class="comment"> * 然后等待j从右往左遍历找到一个pivot小的数，两者交换，然后继续寻找直到i=j，for循环结束。</span></span><br><span class="line"><span class="comment"> * 之后我们需要做判断，如果pivot比i所指数据大就交换两者，否则i回退一步（因为开始忽略了首元素）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Partion2</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left &gt;= right)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = left + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j = right;</span><br><span class="line">T pivot = <span class="built_in">array</span>[left];<span class="comment">// 取第一个数为基准</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; j)&#123;<span class="comment">// 循环直至 i,j 相遇</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; j &amp;&amp; <span class="built_in">array</span>[j] &gt;= pivot)<span class="comment">// j向左遍历，直到找到比pivot小的值</span></span><br><span class="line">--j;</span><br><span class="line"><span class="keyword">while</span> (i &lt; j &amp;&amp; <span class="built_in">array</span>[i] &lt; pivot)<span class="comment">// i向右遍历，直到找到比pivot大的值</span></span><br><span class="line">++i;</span><br><span class="line"><span class="keyword">if</span> (i &lt; j)<span class="comment">// 如果i &lt; j，就交换刚才找到的那两个值</span></span><br><span class="line">swap(<span class="built_in">array</span>[j], <span class="built_in">array</span>[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[i] &lt;= <span class="built_in">array</span>[left])<span class="comment">// 这里一定要做判断再决定是否交换</span></span><br><span class="line">swap(<span class="built_in">array</span>[i], <span class="built_in">array</span>[left]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span><span class="comment">// 如果不交换，说明left是最小，但i是不是第二小不确定，所以需要下次判断</span></span><br><span class="line">--i;</span><br><span class="line">Partion2(<span class="built_in">array</span>, left, i - <span class="number">1</span>);</span><br><span class="line">Partion2(<span class="built_in">array</span>, i + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 快速排序3：</span></span><br><span class="line"><span class="comment"> * 将第一个元素array[left]提出来作pivot，然后从j = right向前搜索第一个比pivot小的元素假设为array[k]，</span></span><br><span class="line"><span class="comment"> * 该元素放在array[left]的位置。因为array[left]已经保存pivot覆盖也没关系，于是array[k]又可以被覆盖了，</span></span><br><span class="line"><span class="comment"> * 从前往后搜索比pivot大的元素放到array[k]。一直进行下去直到i=j。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Partion3</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left &gt;= right)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = left;</span><br><span class="line"><span class="keyword">int</span> j = right;</span><br><span class="line">T pivot = <span class="built_in">array</span>[left];<span class="comment">// 取第一个数为基准</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; j)&#123;<span class="comment">// 循环直至 i,j 相遇</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; j &amp;&amp; <span class="built_in">array</span>[j] &gt;= pivot)</span><br><span class="line">--j; </span><br><span class="line"><span class="keyword">if</span> (i &lt; j)</span><br><span class="line"><span class="built_in">array</span>[i++] = <span class="built_in">array</span>[j];<span class="comment">// 从右向左扫描，将比基准小的数填到左边</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; j &amp;&amp; <span class="built_in">array</span>[i] &lt; pivot)</span><br><span class="line">++i; </span><br><span class="line"><span class="keyword">if</span> (i &lt; j)</span><br><span class="line"><span class="built_in">array</span>[j--] = <span class="built_in">array</span>[i];<span class="comment">// 从左向右扫描，将比基准大的数填到右边</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">array</span>[i] = pivot;<span class="comment">// 将基准数填回</span></span><br><span class="line">Partion3(<span class="built_in">array</span>, left, i - <span class="number">1</span>);</span><br><span class="line">Partion3(<span class="built_in">array</span>, i + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 快速排序迭代实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSortIteration</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">const</span> <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; trace;</span><br><span class="line">trace.push(make_pair(<span class="number">0</span>, length - <span class="number">1</span>));<span class="comment">// 将数组首尾压栈</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!trace.empty()) &#123;</span><br><span class="line"><span class="keyword">auto</span> top = trace.top();<span class="comment">// 将栈顶元素保存下来</span></span><br><span class="line">trace.pop();<span class="comment">// 弹出栈顶</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = top.first;<span class="comment">// 取出首尾地址</span></span><br><span class="line"><span class="keyword">int</span> j = top.second;</span><br><span class="line"></span><br><span class="line">T pivot = <span class="built_in">array</span>[i];<span class="comment">// 取第一个数为基准</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &lt; j) &#123;<span class="comment">// 循环直至 i,j 相遇</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; j &amp;&amp; <span class="built_in">array</span>[j] &gt;= pivot)</span><br><span class="line">--j;</span><br><span class="line"><span class="keyword">if</span> (i &lt; j)</span><br><span class="line"><span class="built_in">array</span>[i++] = <span class="built_in">array</span>[j];<span class="comment">// 从右向左扫描，将比基准小的数填到左边</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; j &amp;&amp; <span class="built_in">array</span>[i] &lt; pivot)</span><br><span class="line">++i;</span><br><span class="line"><span class="keyword">if</span> (i &lt; j)</span><br><span class="line"><span class="built_in">array</span>[j--] = <span class="built_in">array</span>[i];<span class="comment">// 从左向右扫描，将比基准大的数填到右边</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">array</span>[i] = pivot;<span class="comment">// 将基准数填回</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i &gt; top.first) trace.push(make_pair(top.first, i - <span class="number">1</span>));</span><br><span class="line"><span class="keyword">if</span> (j &lt; top.second) trace.push(make_pair(j + <span class="number">1</span>, top.second));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><ul><li>数据结构    不定</li><li>最坏时间复杂度    ${\displaystyle O(n^{2})}$ </li><li>最优时间复杂度    ${\displaystyle O(n\log n)}$ </li><li>平均时间复杂度    ${\displaystyle O(n\log n)}$ </li><li>空间复杂度    根据实现的方式不同而不同</li></ul><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>&emsp;&emsp;快速排序是二叉查找树（二叉查找树）的一个空间最优化版本。不是循序地把数据项插入到一个明确的树中，而是由快速排序组织这些数据项到一个由递归调用所隐含的树中。这两个算法完全地产生相同的比较次数，但是顺序不同。对于排序算法的稳定性指标，原地分区版本的快速排序算法是不稳定的。其他变种是可以通过牺牲性能和空间来维护稳定性的。</p><p>&emsp;&emsp;快速排序的最直接竞争者是堆排序（Heapsort）。堆排序通常比快速排序稍微慢，但是最坏情况的运行时间总是 ${\displaystyle O(n\log n)}$ 。快速排序是经常比较快，除了introsort变化版本外，仍然有最坏情况性能的机会。如果事先知道堆排序将会是需要使用的，那么直接地使用堆排序比等待introsort再切换到它还要快。堆排序也拥有重要的特点，仅使用固定额外的空间（堆排序是原地排序），而即使是最佳的快速排序变化版本也需要 ${\displaystyle O(\log n)}$ 的空间。然而，堆排序需要有效率的随机存取才能变成可行。</p><p>&emsp;&emsp;快速排序也与归并排序（Mergesort）竞争，这是另外一种递归排序算法，但有坏情况 ${\displaystyle O(n\log n)}$ 运行时间的优势。不像快速排序或堆排序，归并排序是一个稳定排序，且可以轻易地被采用在链表（linked list）和存储在慢速访问媒体上像是磁盘存储或网络连接存储的非常巨大数列。尽管快速排序可以被重新改写使用在链串列上，但是它通常会因为无法随机存取而导致差的基准选择。归并排序的主要缺点，是在最佳情况下需要 ${\displaystyle \Omega (n)}$ 额外的空间。</p><h4 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h4><p>&emsp;&emsp;快排的优化、归并排序的优化一向是面试的考察重点，至于算法的优化，重点还是要知道现有算法的不足之处。</p><ul><li>当序列长度很小时，快排效率低，研究表明长度在5~25的数组，快排表现不如插入排序。</li><li>当pivot选择不当是，会导致树的不平衡，这样导致快排的时间复杂度为${\displaystyle O(n^{2})}$。</li><li>当数组中有大量重复的元素，快排效率将非常之低。</li></ul><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>&emsp;&emsp;针对上面提出的快排的局限性，我们依次做出优化策略：</p><ul><li>当当前序列长度小于特定值时，直接采用插入排序，或者不做处理，等到快排都执行完毕后（大致有序）在执行一次插入排序。</li><li>针对pivot的选择，不再选取固定值，而是采用其他选取策略，如随机、三值取中等。</li><li>如果数组中重复元素多，就采用三路划分算法：以某个数为基准将一个数组分成三部分：第一部分表示小于该pivot，第二部分等于pivot，第三部分大于pivot，要得到三部分得区间范围。</li></ul><p>&emsp;&emsp;下面的代码是对上述改进算法的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 快速排序3优化1：</span></span><br><span class="line"><span class="comment">* 当排序的子序列小于预定的值M时，采用插入排序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PartionInsert</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left &gt;= right)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (right - left &lt;= M)</span><br><span class="line">InsertSort(<span class="built_in">array</span>, left, right);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = left;</span><br><span class="line"><span class="keyword">int</span> j = right;</span><br><span class="line">T pivot = <span class="built_in">array</span>[left];<span class="comment">// 取第一个数为基准</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; j)&#123;<span class="comment">// 循环直至 i,j 相遇</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; j &amp;&amp; <span class="built_in">array</span>[j] &gt;= pivot)</span><br><span class="line">--j;</span><br><span class="line"><span class="keyword">if</span> (i &lt; j)</span><br><span class="line"><span class="built_in">array</span>[i++] = <span class="built_in">array</span>[j];<span class="comment">// 从右向左扫描，将比基准小的数填到左边</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; j &amp;&amp; <span class="built_in">array</span>[i] &lt; pivot)</span><br><span class="line">++i;</span><br><span class="line"><span class="keyword">if</span> (i &lt; j)</span><br><span class="line"><span class="built_in">array</span>[j--] = <span class="built_in">array</span>[i];<span class="comment">// 从左向右扫描，将比基准大的数填到右边</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">array</span>[i] = pivot;<span class="comment">// 将基准数填回</span></span><br><span class="line">PartionInsert(<span class="built_in">array</span>, left, i - <span class="number">1</span>);</span><br><span class="line">PartionInsert(<span class="built_in">array</span>, i + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//产生随机数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Random</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> size = right - left + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> i = left + rand() % size;</span><br><span class="line">swap(<span class="built_in">array</span>[i], <span class="built_in">array</span>[left]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取中位数移至left</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Median</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid = left + ((right - left )&gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> minIndex = right;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[minIndex] &gt; <span class="built_in">array</span>[mid])</span><br><span class="line">minIndex = mid;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[minIndex] &gt; <span class="built_in">array</span>[left])</span><br><span class="line">minIndex = left;</span><br><span class="line"><span class="keyword">if</span> (minIndex != right)<span class="comment">//三个判断，把最小值移到最右侧</span></span><br><span class="line">swap(<span class="built_in">array</span>[minIndex], <span class="built_in">array</span>[right]);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[mid] &lt; <span class="built_in">array</span>[left])<span class="comment">//那么剩下的两个数，最小的那个就是中位数了</span></span><br><span class="line">swap(<span class="built_in">array</span>[left], <span class="built_in">array</span>[mid]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 快速排序3优化2：</span></span><br><span class="line"><span class="comment">* 取随机数或者三值取中作为基准值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PartionSecond</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left &gt;= right)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Random(array, left, right);// 优化2-1：取随机数至最左端（基准值）</span></span><br><span class="line">Median(<span class="built_in">array</span>, left, right);<span class="comment">// 优化2-2：取中位数至最左端（基准值）</span></span><br><span class="line"><span class="keyword">int</span> i = left;</span><br><span class="line"><span class="keyword">int</span> j = right;</span><br><span class="line">T pivot = <span class="built_in">array</span>[left];<span class="comment">// 取第一个数为基准</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; j)&#123;<span class="comment">// 循环直至 i,j 相遇</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; j &amp;&amp; <span class="built_in">array</span>[j] &gt;= pivot)</span><br><span class="line">--j;</span><br><span class="line"><span class="keyword">if</span> (i &lt; j)</span><br><span class="line"><span class="built_in">array</span>[i++] = <span class="built_in">array</span>[j];<span class="comment">// 从右向左扫描，将比基准小的数填到左边</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; j &amp;&amp; <span class="built_in">array</span>[i] &lt; pivot)</span><br><span class="line">++i;</span><br><span class="line"><span class="keyword">if</span> (i &lt; j)</span><br><span class="line"><span class="built_in">array</span>[j--] = <span class="built_in">array</span>[i];<span class="comment">// 从左向右扫描，将比基准大的数填到右边</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">array</span>[i] = pivot;<span class="comment">// 将基准数填回</span></span><br><span class="line">PartionSecond(<span class="built_in">array</span>, left, i - <span class="number">1</span>);</span><br><span class="line">PartionSecond(<span class="built_in">array</span>, i + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 快速排序3优化3：</span></span><br><span class="line"><span class="comment">* 重复数据比较多的话，可以分为小于等于大于三段</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PartionThird</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left &gt;= right)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> less = left;</span><br><span class="line"><span class="keyword">int</span> greater = right;</span><br><span class="line"><span class="keyword">int</span> it = left;</span><br><span class="line">T pivot = <span class="built_in">array</span>[left];<span class="comment">// 取第一个数为基准</span></span><br><span class="line"><span class="keyword">while</span> (it &lt;= greater)&#123;<span class="comment">// 循环直至it和greater相遇</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[it] == pivot)<span class="comment">// 如果等于pivot，it右移</span></span><br><span class="line">++it;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">array</span>[it] &lt; pivot)&#123;<span class="comment">// 如果小于pivot，扔左边，it和less右移</span></span><br><span class="line">swap(<span class="built_in">array</span>[less], <span class="built_in">array</span>[it]);</span><br><span class="line">++it;</span><br><span class="line">++less;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;<span class="comment">// 如果大于pivot，扔右边，greater左移</span></span><br><span class="line">swap(<span class="built_in">array</span>[greater], <span class="built_in">array</span>[it]);</span><br><span class="line">--greater;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">PartionThird(<span class="built_in">array</span>, left, less - <span class="number">1</span>);</span><br><span class="line">PartionThird(<span class="built_in">array</span>, greater + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://wordzzzz.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序" scheme="http://wordzzzz.gitee.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="快速排序" scheme="http://wordzzzz.gitee.io/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法系列之一：八大排序之冒泡排序</title>
    <link href="http://wordzzzz.gitee.io/2018/01/05/DS/"/>
    <id>http://wordzzzz.gitee.io/2018/01/05/DS/</id>
    <published>2018-01-04T16:00:00.000Z</published>
    <updated>2018-01-09T12:39:06.536Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>个人博客：<a href="https://wordzzzz.github.io/" target="_blank" rel="noopener">https://wordzzzz.github.io/</a> &amp;&amp; <a href="https://wordzzzz.gitee.io/">https://wordzzzz.gitee.io/</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/DS-A" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/DS-A</a></strong></li><li><strong>博客作者：WordZzzz，一只热爱技术的文艺青年</strong></li></ul><hr><p>[toc]</p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;建议先看排序综述，传送门：<a href="http://blog.csdn.net/u011475210/article/details/79014021" target="_blank" rel="noopener">数据结构与算法系列之一：八大排序综述</a>。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>&emsp;&emsp;冒泡排序（英语：Bubble Sort，台湾另外一种译名为：泡沫排序）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p><p>&emsp;&emsp;冒泡排序对 ${\displaystyle n}$ 个项目需要${\displaystyle O(n)}$ )的比较次数，且可以原地排序。尽管这个算法是最简单了解和实现的排序算法之一，但它对于包含大量的元素的数列排序是很没有效率的。</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>冒泡排序算法的运作如下：</p><ul><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ul><p>由于它的简洁，冒泡排序通常被用来对于程序设计入门的学生介绍算法的概念。</p><h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>&emsp;&emsp;wikipedia的大数据规模演示：</p><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20180108094645331?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="bubblesort from wikipedia"></div><br><p></p><p>&emsp;&emsp;wordzzzz的小数据规模演示：</p><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20180108095446582?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="bubblesort from wordzzzz"></div><br><p></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 标准冒泡排序：嵌套循环比大小。</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">const</span> <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span> == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">throw</span> invalid_argument(<span class="string">"Array must not be empty"</span>);</span><br><span class="line"><span class="keyword">if</span> (length &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; ++i)&#123;<span class="comment">//外循环，每次循环确定一个最大值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length - <span class="number">1</span> - i; ++j)&#123;<span class="comment">//内循环，用于交换数据，遍历次数递减</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[j] &gt; <span class="built_in">array</span>[j + <span class="number">1</span>])&#123;<span class="comment">//如果当前数据比后面的数据大，则交换</span></span><br><span class="line">T tmp = <span class="built_in">array</span>[j + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">array</span>[j + <span class="number">1</span>] = <span class="built_in">array</span>[j];</span><br><span class="line"><span class="built_in">array</span>[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><ul><li>数据结构    数组</li><li>最坏时间复杂度    ${\displaystyle O(n^{2})}$</li><li>最优时间复杂度    ${\displaystyle O(n)}$</li><li>平均时间复杂度    ${\displaystyle O(n^{2})}$</li><li>空间复杂度    总共 ${\displaystyle O(n)}$，需要辅助空间 ${\displaystyle O(1)}$</li></ul><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>&emsp;&emsp;冒泡排序是与插入排序拥有相等的运行时间，但是两种算法在需要的交换次数却很大地不同。在最坏的情况，冒泡排序需要 ${\displaystyle O(n^{2})}$次交换，而插入排序只要最多 ${\displaystyle O(n)}$ 交换。冒泡排序的实现（类似上面）通常会对已经排序好的数列拙劣地运行（ ${\displaystyle O(n^{2})}$ ），而插入排序在这个例子只需要 ${\displaystyle O(n)}$ 个运算。因此很多现代的算法教科书避免使用冒泡排序，而用插入排序取代之。</p><p>&emsp;&emsp;在面试中，一般都会涉及到算法的优化，重点考察的其实还是你对现有算法的理解，分析现有算法的缺点，就能找到优化的思路。</p><p>优化1：冒泡排序如果能在内部循环第一次运行时，使用一个旗标来表示有无需要交换的可能，也可以把最优情况下的复杂度降低到 ${\displaystyle O(n)}$ 。在这个情况，已经排序好的数列就无交换的需要。<br>优化2：可以记录某次遍历时最后发生数据交换的位置，这个位置之后的数据显然已经有序，不用再排序了。因此通过记录最后发生数据交换的位置就可以确定下次循环的范围了。<br>优化3：若在每次走访数列时，把走访顺序反过来，也可以稍微地改进效率。有时候称为鸡尾酒排序，因为算法会从数列的一端到另一端之间穿梭往返。</p><p>优化代码如下：</p><p>优化1：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 冒泡排序优化1：如果某次内循环没有改变任何数据，则结束。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort1</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">const</span> <span class="keyword">int</span> length)</span> </span>&#123; </span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span> == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">throw</span> invalid_argument(<span class="string">"Array must not be empty"</span>); </span><br><span class="line"><span class="keyword">if</span> (length &lt;= <span class="number">0</span>) </span><br><span class="line"><span class="keyword">return</span>; </span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">false</span>;<span class="comment">//设置标志位，用来判断内循环是否有数据交换</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; ++i)&#123;<span class="comment">//外循环，每次循环确定一个最大值</span></span><br><span class="line">flag = <span class="literal">false</span>;<span class="comment">//外循环第一步需要重置标志位</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length - <span class="number">1</span> - i; ++j)&#123;<span class="comment">//内循环，用于交换数据，遍历次数递减</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[j] &gt; <span class="built_in">array</span>[j + <span class="number">1</span>])&#123;<span class="comment">//如果当前数据比后面的数据大，则交换</span></span><br><span class="line">T tmp = <span class="built_in">array</span>[j + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">array</span>[j + <span class="number">1</span>] = <span class="built_in">array</span>[j];</span><br><span class="line"><span class="built_in">array</span>[j] = tmp;</span><br><span class="line">flag = <span class="literal">true</span>;<span class="comment">//如果有交换，则标志位置1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!flag) <span class="keyword">return</span>;<span class="comment">//如果本次循环没有数据交换，则结束排序</span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化2：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 冒泡排序优化2：在优化1的基础上，记录上次排序结束位置，减少排序次数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort2</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">const</span> <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span> == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">throw</span> invalid_argument(<span class="string">"Array must not be empty"</span>);</span><br><span class="line"><span class="keyword">if</span> (length &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> k = length;</span><br><span class="line"><span class="keyword">int</span> flag = k;<span class="comment">//设置标志位，用来判断内循环是否有数据交换</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; ++i)&#123;<span class="comment">//外循环，每次循环确定一个最大值</span></span><br><span class="line">k = flag;</span><br><span class="line">flag = <span class="number">0</span>;<span class="comment">//外循环第一步需要重置标志位</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k - <span class="number">1</span>; ++j)&#123;<span class="comment">//内循环，用于交换数据，遍历次数递减</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[j] &gt; <span class="built_in">array</span>[j + <span class="number">1</span>])&#123;<span class="comment">//如果当前数据比后面的数据大，则交换</span></span><br><span class="line">T tmp = <span class="built_in">array</span>[j + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">array</span>[j + <span class="number">1</span>] = <span class="built_in">array</span>[j];</span><br><span class="line"><span class="built_in">array</span>[j] = tmp;</span><br><span class="line">flag = j + <span class="number">1</span>;<span class="comment">//如果有交换，更新交换位置的记录</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!flag) <span class="keyword">return</span>;<span class="comment">//如果本次循环没有数据交换，则结束排序</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化3：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *冒泡排序优化3：鸡尾酒排序，一个外循环内跑两个内循环。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort3</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">const</span> <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span> == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">throw</span> invalid_argument(<span class="string">"Array must not be empty"</span>);</span><br><span class="line"><span class="keyword">if</span> (length &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> high = length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (high &gt; low)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = low; i &lt; high; ++i)<span class="comment">//正向冒泡，确定最大值  </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[i] &gt; <span class="built_in">array</span>[i + <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">T temp = <span class="built_in">array</span>[i];</span><br><span class="line"><span class="built_in">array</span>[i] = <span class="built_in">array</span>[i + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">array</span>[i + <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">--high;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = high; j &gt; low; --j)<span class="comment">//反向冒泡，确定最小值  </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[j] &lt; <span class="built_in">array</span>[j - <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">T temp = <span class="built_in">array</span>[j];</span><br><span class="line"><span class="built_in">array</span>[j] = <span class="built_in">array</span>[j - <span class="number">1</span>];</span><br><span class="line"><span class="built_in">array</span>[j - <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">++low;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://wordzzzz.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序" scheme="http://wordzzzz.gitee.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="冒泡排序" scheme="http://wordzzzz.gitee.io/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法系列之一：八大排序之堆排序</title>
    <link href="http://wordzzzz.gitee.io/2018/01/04/DS/"/>
    <id>http://wordzzzz.gitee.io/2018/01/04/DS/</id>
    <published>2018-01-03T16:00:00.000Z</published>
    <updated>2018-01-09T12:38:42.394Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>个人博客：<a href="https://wordzzzz.github.io/" target="_blank" rel="noopener">https://wordzzzz.github.io/</a> &amp;&amp; <a href="https://wordzzzz.gitee.io/">https://wordzzzz.gitee.io/</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/DS-A" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/DS-A</a></strong></li><li><strong>博客作者：WordZzzz，一只热爱技术的文艺青年</strong></li></ul><hr><p>[toc]</p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;建议先看排序综述，传送门：<a href="http://blog.csdn.net/u011475210/article/details/79014021" target="_blank" rel="noopener">数据结构与算法系列之一：八大排序综述</a>。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>&emsp;&emsp;堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><p>&emsp;&emsp;通常堆是通过一维数组来实现的。在数组起始位置为0的情形中：</p><ul><li>父节点i的左子节点在位置 ${\displaystyle (2i+1)}$。</li><li>父节点i的右子节点在位置 ${\displaystyle (2i+2)}$。</li><li>子节点i的父节点在位置 ${\displaystyle floor((i-1)/2)}$。</li></ul><p>&emsp;&emsp;在堆的数据结构中，堆中的最大值总是位于根节点(在优先队列中使用堆的话堆中的最小值位于根节点)。堆中定义以下几种操作：</p><ul><li>最大堆调整（Max_Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点。</li><li>创建最大堆（Build_Max_Heap）：将堆所有数据重新排序。</li><li>堆排序（HeapSort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算。</li></ul><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>&emsp;&emsp;基于以上堆相关的操作，我们可以很容易的定义堆排序。例如，假设我们已经读入一系列数据并创建了一个堆，一个最直观的算法就是反复的调用del_max()函数，因为该函数总是能够返回堆中最大的值，然后把它从堆中删除，从而对这一系列返回值的输出就得到了该序列的降序排列。真正的原地堆排序使用了另外一个小技巧。堆排序的过程是：</p><ul><li>创建一个堆 ${\displaystyle H[0..n-1]}$。</li><li>把堆首（最大值）和堆尾互换。</li><li>把堆的尺寸缩小1，并调用shift_down(0),目的是把新的数组顶端数据调整到相应位置。</li><li>重复步骤2，直到堆的尺寸为1。</li></ul><h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>&emsp;&emsp;wikipedia的大数据规模演示：</p><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20180108145757178?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="heapsort from wikipedia"></div><br><p></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="递归版"><a href="#递归版" class="headerlink" title="递归版"></a>递归版</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 堆排序递归版</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MaxHeapifyRecursive</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">int</span> i, <span class="keyword">int</span> heapSize)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> sonl = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> sonr = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> dad = i;</span><br><span class="line"><span class="keyword">if</span> (sonl &lt;= heapSize &amp;&amp; <span class="built_in">array</span>[sonl]&gt;<span class="built_in">array</span>[i])&#123;<span class="comment">//如果左子结点大于父结点，则父结点指向子结点</span></span><br><span class="line">dad = sonl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (sonr &lt;= heapSize &amp;&amp; <span class="built_in">array</span>[sonr]&gt;<span class="built_in">array</span>[dad])&#123;<span class="comment">//如果右子结点大于父结点，则父结点指向子结点</span></span><br><span class="line">dad = sonr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (dad != i)&#123;<span class="comment">//如果dad != i则说明父结点不是最大值，交换后递归执行MaxHeapifyRecursive</span></span><br><span class="line">swap(<span class="built_in">array</span>[i], <span class="built_in">array</span>[dad]);</span><br><span class="line">MaxHeapifyRecursive(<span class="built_in">array</span>, dad, heapSize);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">const</span> <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span> == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">throw</span> invalid_argument(<span class="string">"Array must not be empty"</span>);</span><br><span class="line"><span class="keyword">if</span> (length &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化，i从最后一个父结点开始调整</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line"><span class="comment">//构建最大堆 </span></span><br><span class="line">MaxHeapifyRecursive(<span class="built_in">array</span>, i, length - <span class="number">1</span>);</span><br><span class="line"><span class="comment">//MaxHeapifyIteration(array, i, length - 1);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//先将第一个元素和已经排好的元素前一位做交换，再从新调整（刚调整的元素之前的元素），直到排序完毕</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">swap(<span class="built_in">array</span>[<span class="number">0</span>], <span class="built_in">array</span>[i]);</span><br><span class="line">MaxHeapifyRecursive(<span class="built_in">array</span>, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line"><span class="comment">//MaxHeapifyIteration(array, 0, i - 1);</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="迭代版"><a href="#迭代版" class="headerlink" title="迭代版"></a>迭代版</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 堆排序迭代版</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MaxHeapifyIteration</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="comment">//建立父结点指针和子结点指针</span></span><br><span class="line"><span class="keyword">int</span> dad = left;</span><br><span class="line"><span class="keyword">int</span> son = dad * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (son &lt;= right) &#123;<span class="comment">//若子结点指针在范围内才做比较</span></span><br><span class="line"><span class="keyword">if</span> (son + <span class="number">1</span> &lt;= right &amp;&amp; <span class="built_in">array</span>[son] &lt; <span class="built_in">array</span>[son + <span class="number">1</span>])<span class="comment">//先比较两个子结点的大小，选择最大的</span></span><br><span class="line">son++;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[dad] &gt; <span class="built_in">array</span>[son])<span class="comment">//如果父结点大于子结点代表调整完毕，直接跳出循环</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">//否则交换父子内容在继续子结点和孙结点的比较</span></span><br><span class="line">swap(<span class="built_in">array</span>[dad], <span class="built_in">array</span>[son]);</span><br><span class="line">dad = son;</span><br><span class="line">son = dad * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">const</span> <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span> == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">throw</span> invalid_argument(<span class="string">"Array must not be empty"</span>);</span><br><span class="line"><span class="keyword">if</span> (length &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化，i从最后一个父结点开始调整</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line"><span class="comment">//构建最大堆 </span></span><br><span class="line"><span class="comment">//MaxHeapifyRecursive(array, i, length - 1);</span></span><br><span class="line">MaxHeapifyIteration(<span class="built_in">array</span>, i, length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//先将第一个元素和已经排好的元素前一位做交换，再从新调整（刚调整的元素之前的元素），直到排序完毕</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">swap(<span class="built_in">array</span>[<span class="number">0</span>], <span class="built_in">array</span>[i]);</span><br><span class="line"><span class="comment">//MaxHeapifyRecursive(array, 0, i - 1);</span></span><br><span class="line">MaxHeapifyIteration(<span class="built_in">array</span>, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><ul><li>数据结构    数组</li><li>最坏时间复杂度    ${\displaystyle O(n\log n)}$</li><li>最优时间复杂度    ${\displaystyle O(n\log n)}$</li><li>平均时间复杂度    ${\displaystyle O(n\log n)}$ </li><li>空间复杂度    ${\displaystyle O(n)}$ total, ${\displaystyle O(1)}$ auxiliary</li></ul><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>&emsp;&emsp;原地堆排序已经是空间优化版本了，因为它不再需要申请额外的空间。</p><p>&emsp;&emsp;整个算法的过程分为建堆和排序两个过程，首先对现有数组建立最大堆，然后一边提取堆顶的最大值，一边减小堆的尺寸，最后堆尺寸为1时，排序也就完成了。如果大家对整个算法的执行过程不太了解，可以看一下下面这两张图，第一张是建堆的过程示意图，第二张是排序的过程示意图。图片来自：<a href="http://bubkoo.com/2014/01/14/sort-algorithm/heap-sort/" target="_blank" rel="noopener">http://bubkoo.com/2014/01/14/sort-algorithm/heap-sort/</a></p><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20180108145915265?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="bubblesort from wordzzzz"></div><br><p></p><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20180108145935165?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="bubblesort from wordzzzz"></div><br><p></p><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://wordzzzz.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序" scheme="http://wordzzzz.gitee.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="堆排序" scheme="http://wordzzzz.gitee.io/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法系列之一：八大排序之选择排序</title>
    <link href="http://wordzzzz.gitee.io/2018/01/03/DS/"/>
    <id>http://wordzzzz.gitee.io/2018/01/03/DS/</id>
    <published>2018-01-02T16:00:00.000Z</published>
    <updated>2018-01-09T12:38:25.950Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>个人博客：<a href="https://wordzzzz.github.io/" target="_blank" rel="noopener">https://wordzzzz.github.io/</a> &amp;&amp; <a href="https://wordzzzz.gitee.io/">https://wordzzzz.gitee.io/</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/DS-A" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/DS-A</a></strong></li><li><strong>博客作者：WordZzzz，一只热爱技术的文艺青年</strong></li></ul><hr><p>[toc]</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;建议先看排序综述，传送门：<a href="http://blog.csdn.net/u011475210/article/details/79014021" target="_blank" rel="noopener">数据结构与算法系列之一：八大排序综述</a>。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>&emsp;&emsp;选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p><p>&emsp;&emsp;选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对 ${\displaystyle n}$ 个元素的表进行排序总共进行至多 ${\displaystyle n-1}$ 次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ul><li>找到列表中的最小值。</li><li>把它和第一个位置的元素交换。</li><li>列表其余部分重复上面的步骤(从第二个位置开始，且每次加1)。</li></ul><h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>&emsp;&emsp;wikipedia的大数据规模演示：</p><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20180108111324944?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="selectsort from wikipedia"></div><br><p></p><p>&emsp;&emsp;wordzzzz的小数据规模演示：</p><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20180108111351977?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="selectsort from wordzzzz"></div><br><p></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*直接选择排序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">const</span> <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span> == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">throw</span> invalid_argument(<span class="string">"Array must not be empty"</span>);</span><br><span class="line"><span class="keyword">if</span> (length &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; ++i)&#123;<span class="comment">//外循环，每次选出一个最小的元素放到前面</span></span><br><span class="line"><span class="keyword">int</span> min = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; length; ++j)<span class="comment">//内循环，确定最小元素的下标</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[j] &lt; <span class="built_in">array</span>[min])</span><br><span class="line">min = j;</span><br><span class="line"><span class="keyword">if</span> (min != i)&#123;<span class="comment">//如果当前数据不是最小元素，就交换</span></span><br><span class="line">T tmp = <span class="built_in">array</span>[i];</span><br><span class="line"><span class="built_in">array</span>[i] = <span class="built_in">array</span>[min];</span><br><span class="line"><span class="built_in">array</span>[min] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><ul><li>数据结构    数组</li><li>最坏时间复杂度    ${\displaystyle O(n^2)}$ </li><li>最优时间复杂度    ${\displaystyle O(n^2)}$</li><li>平均时间复杂度    ${\displaystyle O(n^2)}$</li><li>空间复杂度    ${\displaystyle O(n)}$ total, ${\displaystyle O(1)}$ auxiliary</li></ul><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>&emsp;&emsp;选择排序的交换操作介于 ${\displaystyle 0}$ 和 ${\displaystyle (n-1)}$ 次之间。选择排序的比较操作为 ${\displaystyle n(n-1)/2}$ 次之间。选择排序的赋值操作介于 ${\displaystyle 0}$ 和 ${\displaystyle 3(n-1)}$ 次之间。</p><p>&emsp;&emsp;比较次数 ${\displaystyle O(n^{2})}$ ，比较次数与关键字的初始状态无关，总的比较次数 ${\displaystyle N=(n-1)+(n-2)+…+1=n\times (n-1)/2}$ 。交换次数 ${\displaystyle O(n)}$ ，最好情况是，已经有序，交换0次；最坏情况是，逆序，交换 ${\displaystyle n-1} 次。交换次数比冒泡排序较少，由于交换所需CPU时间比比较所需的CPU时间多， ${\displaystyle n}$ 值较小时，选择排序比冒泡排序快。</p><p>&emsp;&emsp;原地操作几乎是选择排序的唯一优点，当空间复杂度要求较高时，可以考虑选择排序；实际适用的场合非常罕见。</p><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://wordzzzz.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序" scheme="http://wordzzzz.gitee.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="选择排序" scheme="http://wordzzzz.gitee.io/tags/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
</feed>
